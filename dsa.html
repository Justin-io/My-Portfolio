<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Justin-docs</title>
    <style>



        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #fff;
        }
        
        .header {
            text-align: center;
            border-bottom: 3px solid #2c3e50;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.5em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        
        .author {
            font-size: 1.1em;
            color: #95a5a6;
            font-style: italic;
        }
        
        .citation {
            font-size: 0.9em;
            color: #7f8c8d;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        .section {
            margin-bottom: 40px;
            page-break-inside: avoid;
        }
        
        .section-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .concept {
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #e74c3c;
        }
        
        .simple-explanation {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 2px solid #27ae60;
        }
        
        .simple-title {
            font-weight: bold;
            color: #27ae60;
            margin-bottom: 10px;
        }
        
        .deep-explanation {
            background: #fff;
            padding: 15px;
            border-radius: 5px;
            border: 2px solid #3498db;
        }
        
        .deep-title {
            font-weight: bold;
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .svg-container {
            text-align: center;
            margin: 20px 0;
            page-break-inside: avoid;
        }
        
        .svg-caption {
            font-size: 0.9em;
            color: #7f8c8d;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        .formula {
            background: #f1f2f6;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 15px 0;
            border: 1px solid #ddd;
        }
        
        .example {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        
        .example-title {
            font-weight: bold;
            color: #856404;
            margin-bottom: 10px;
        }
        
        .code {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        @media print {
            body {
                font-size: 12pt;
                line-height: 1.4;
            }
            
            .header {
                page-break-after: avoid;
            }
            
            .section {
                page-break-inside: avoid;
                margin-bottom: 25px;
            }
            
            .concept {
                page-break-inside: avoid;
            }
            
            .svg-container {
                page-break-inside: avoid;
            }
            
            .title {
                font-size: 2em;
            }
            
            .section-title {
                font-size: 1.5em;
            }
        }
    </style>

  <style>
    /* Fullscreen overlay layer */
    #fullscreen-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0);
      color: white;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 999999;
      cursor: pointer;
      text-align: center;
      font-family: Arial, sans-serif;
    }
    #fullscreen-overlay h2 {
      font-size: 2rem;
      margin: 0 0 1rem;
      animation: pulse 2s infinite;
    }
    #fullscreen-overlay p {
      font-size: 1.2rem;
      opacity: 0.8;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Optional: Hide scrollbar during overlay */
    body.overlay-active {
      overflow: hidden;
    }
  </style>
</head>
<body>
  <!-- Fullscreen overlay (initially hidden via JS logic on first-load check) -->
  <div id="fullscreen-overlay">
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const overlay = document.getElementById('fullscreen-overlay');

      // Show overlay on every fresh load or refresh
      // (No localStorage persistence needed ‚Äî always show on load)
      overlay.style.display = 'flex';
      document.body.classList.add('overlay-active');

      const requestFullscreen = () => {
        const elem = document.documentElement;
        if (elem.requestFullscreen) {
          return elem.requestFullscreen();
        } else if (elem.webkitRequestFullscreen) { // Safari
          return elem.webkitRequestFullscreen();
        } else if (elem.msRequestFullscreen) { // IE11
          return elem.msRequestFullscreen();
        } else {
          alert("Fullscreen is not supported in your browser.");
          return Promise.reject(new Error("Fullscreen API unavailable"));
        }
      };

      // Attach click handler to overlay
      overlay.addEventListener('click', async () => {
        try {
          await requestFullscreen();
          // Remove overlay after successful fullscreen
          overlay.style.display = 'none';
          document.body.classList.remove('overlay-active');

          // Optional: Listen for fullscreen exit to re-show overlay?
          // Uncomment below if you want overlay to reappear on exit
          /*
          document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
              overlay.style.display = 'flex';
              document.body.classList.add('overlay-active');
            }
          });
          */
        } catch (err) {
          console.error("Failed to enter fullscreen:", err);
          // Keep overlay visible so user can try again
        }
      });
    });
  </script>


</head>
<body>
    <div class="header">
        <h1 class="title">Justin-docs</h1>
        <h2 class="subtitle">Module 1: Introduction to Data Structures</h2>
        <p class="author">By Justin</p>
        <p class="citation">Based on 2024 Exam Scheme & 2025 Handbook Reference</p>
    </div>

    <div class="section">
        <h2 class="section-title">1. Data Types and Abstract Data Types</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üß∏ For a 5-Year-Old: What are Data Types?</div>
                <p>Imagine you have different toy boxes: one for LEGO blocks, one for stuffed animals, and one for toy cars. Each box holds only one type of toy. Data types are like these toy boxes - they tell the computer what kind of information you're storing, like numbers, words, or true/false answers!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üìö Formal Definition & Technical Details</div>
                <p><strong>Data Types</strong> are classifications that specify which type of value a variable can hold and what operations can be performed on it. In programming, data types define the size, range, and behavior of data stored in memory.</p>
                
                <div class="svg-container">
                    <svg width="600" height="300" viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg">
                        <!-- Primitive Data Types -->
                        <rect x="50" y="50" width="120" height="80" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="110" y="85" text-anchor="middle" fill="white" font-weight="bold">INTEGER</text>
                        <text x="110" y="105" text-anchor="middle" fill="white" font-size="12">Whole numbers</text>
                        
                        <rect x="200" y="50" width="120" height="80" fill="#e74c3c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="260" y="85" text-anchor="middle" fill="white" font-weight="bold">FLOAT</text>
                        <text x="260" y="105" text-anchor="middle" fill="white" font-size="12">Decimal numbers</text>
                        
                        <rect x="350" y="50" width="120" height="80" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="410" y="85" text-anchor="middle" fill="white" font-weight="bold">CHARACTER</text>
                        <text x="410" y="105" text-anchor="middle" fill="white" font-size="12">Single letters</text>
                        
                        <!-- Derived Data Types -->
                        <rect x="125" y="160" width="120" height="80" fill="#f39c12" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="185" y="195" text-anchor="middle" fill="white" font-weight="bold">ARRAY</text>
                        <text x="185" y="215" text-anchor="middle" fill="white" font-size="12">Collection of items</text>
                        
                        <rect x="275" y="160" width="120" height="80" fill="#9b59b6" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="335" y="195" text-anchor="middle" fill="white" font-weight="bold">STRUCTURE</text>
                        <text x="335" y="215" text-anchor="middle" fill="white" font-size="12">Group of different types</text>
                        
                        <!-- Arrows showing relationships -->
                        <path d="M 110 130 L 185 160" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                        <path d="M 260 130 L 335 160" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                        
                        <!-- Arrow marker definition -->
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                            </marker>
                        </defs>
                        
                        <text x="300" y="30" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Data Types Classification</text>
                    </svg>
                    <div class="svg-caption">Figure 1: Classification of Primitive and Derived Data Types</div>
                </div>
                
                <p><strong>Primitive Data Types:</strong></p>
                <ul>
                    <li><strong>Integer:</strong> Whole numbers (e.g., 42, -17, 0)</li>
                    <li><strong>Float/Double:</strong> Decimal numbers (e.g., 3.14, -0.001)</li>
                    <li><strong>Character:</strong> Single letters or symbols (e.g., 'A', '$')</li>
                    <li><strong>Boolean:</strong> True or false values</li>
                </ul>
                
                <p><strong>Derived Data Types:</strong></p>
                <ul>
                    <li><strong>Array:</strong> Fixed-size collection of same-type elements</li>
                    <li><strong>Structure:</strong> Collection of different-type elements</li>
                    <li><strong>Pointer:</strong> Memory address reference</li>
                </ul>
            </div>
        </div>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üé≠ For a 5-Year-Old: What are Abstract Data Types?</div>
                <p>Think of a TV remote control. You don't need to know how the electronics inside work - you just need to know which buttons to press to change channels or adjust volume. Abstract Data Types are like remote controls - they show you what you can do (the buttons) but hide how it works inside!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîç Formal Definition & Technical Implementation</div>
                <p><strong>Abstract Data Types (ADTs)</strong> are mathematical models for data types where the data type is defined by its behavior (semantics) from the point of view of a user, specifically in terms of possible values, possible operations on data of this type, and the behavior of these operations.</p>
                
                <div class="svg-container">
                    <svg width="700" height="400" viewBox="0 0 700 400" xmlns="http://www.w3.org/2000/svg">
                        <!-- Interface Layer -->
                        <rect x="50" y="50" width="600" height="80" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="350" y="85" text-anchor="middle" fill="white" font-size="18" font-weight="bold">INTERFACE (What you can do)</text>
                        <text x="350" y="110" text-anchor="middle" fill="white" font-size="14">Operations: push(), pop(), isEmpty(), size()</text>
                        
                        <!-- Implementation Layer -->
                        <rect x="50" y="180" width="600" height="80" fill="#e74c3c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="350" y="215" text-anchor="middle" fill="white" font-size="18" font-weight="bold">IMPLEMENTATION (How it works)</text>
                        <text x="350" y="240" text-anchor="middle" fill="white" font-size="14">Array-based or Linked List-based storage</text>
                        
                        <!-- Data Layer -->
                        <rect x="50" y="310" width="600" height="80" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="350" y="345" text-anchor="middle" fill="white" font-size="18" font-weight="bold">DATA (What's stored)</text>
                        <text x="350" y="370" text-anchor="middle" fill="white" font-size="14">Actual values in memory</text>
                        
                        <!-- Arrows showing abstraction -->
                        <path d="M 350 130 L 350 180" stroke="#2c3e50" stroke-width="3" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>
                        <path d="M 350 260 L 350 310" stroke="#2c3e50" stroke-width="3" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>
                        
                        <!-- Arrow marker definition -->
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                            </marker>
                        </defs>
                        
                        <text x="350" y="30" text-anchor="middle" font-size="20" font-weight="bold" fill="#2c3e50">Abstract Data Type: Stack Example</text>
                    </svg>
                    <div class="svg-caption">Figure 2: ADT Abstraction Layers - Stack Example</div>
                </div>
                
                <p><strong>Key Characteristics of ADTs:</strong></p>
                <ul>
                    <li><strong>Encapsulation:</strong> Hides implementation details</li>
                    <li><strong>Abstraction:</strong> Focuses on what operations do, not how</li>
                    <li><strong>Modularity:</strong> Can be used independently of implementation</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üìù Real-World Example: Stack ADT</div>
                    <p><strong>Interface:</strong> push(item), pop(), peek(), isEmpty(), size()</p>
                    <p><strong>Implementation Options:</strong> Array-based, Linked List-based</p>
                    <p><strong>Real-world Analogy:</strong> Stack of plates - you can only add/remove from the top</p>
                </div>
                
                <div class="formula">
                    ADT = {Data Objects} ‚à™ {Operations} ‚à™ {Axioms}
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">2. Algorithm Analysis: Time and Space Complexity</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">‚è±Ô∏è For a 5-Year-Old: What is Algorithm Analysis?</div>
                <p>Imagine you have two ways to clean your room: one way takes 5 minutes, and another way takes 1 hour. Algorithm analysis is like figuring out which way is faster and which way uses more space in your toy box. We want to find the best way that's both fast and doesn't need too much space!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üìä Formal Definition & Mathematical Foundation</div>
                <p><strong>Algorithm Analysis</strong> is the process of determining the amount of time, storage, or other resources required to execute an algorithm. It helps us compare different algorithms and choose the most efficient one for a given problem.</p>
                
                <div class="svg-container">
                    <svg width="700" height="350" viewBox="0 0 700 350" xmlns="http://www.w3.org/2000/svg">
                        <!-- Coordinate system -->
                        <line x1="50" y1="300" x2="650" y2="300" stroke="#2c3e50" stroke-width="2"/>
                        <line x1="50" y1="50" x2="50" y2="300" stroke="#2c3e50" stroke-width="2"/>
                        
                        <!-- Labels -->
                        <text x="350" y="330" text-anchor="middle" font-size="14" fill="#2c3e50">Input Size (n)</text>
                        <text x="25" y="175" text-anchor="middle" font-size="14" fill="#2c3e50" transform="rotate(-90 25 175)">Time</text>
                        
                        <!-- O(1) - Constant -->
                        <line x1="50" y1="250" x2="650" y2="250" stroke="#27ae60" stroke-width="3"/>
                        <text x="660" y="255" font-size="12" fill="#27ae60">O(1)</text>
                        
                        <!-- O(log n) - Logarithmic -->
                        <path d="M 50 280 Q 150 260, 250 240 T 450 200 T 650 180" stroke="#3498db" stroke-width="3" fill="none"/>
                        <text x="660" y="185" font-size="12" fill="#3498db">O(log n)</text>
                        
                        <!-- O(n) - Linear -->
                        <line x1="50" y1="280" x2="650" y2="100" stroke="#f39c12" stroke-width="3"/>
                        <text x="660" y="105" font-size="12" fill="#f39c12">O(n)</text>
                        
                        <!-- O(n¬≤) - Quadratic -->
                        <path d="M 50 290 Q 200 250, 350 150 T 650 50" stroke="#e74c3c" stroke-width="3" fill="none"/>
                        <text x="660" y="55" font-size="12" fill="#e74c3c">O(n¬≤)</text>
                        
                        <!-- Title -->
                        <text x="350" y="30" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Time Complexity Growth Rates</text>
                    </svg>
                    <div class="svg-caption">Figure 3: Comparison of Different Time Complexity Functions</div>
                </div>
                
                <p><strong>Time Complexity:</strong> Measures how the runtime of an algorithm grows with input size.</p>
                <p><strong>Space Complexity:</strong> Measures how the memory usage grows with input size.</p>
                
                <div class="example">
                    <div class="example-title">üî¢ Frequency Count Method Example</div>
                    <div class="code">
for (i = 0; i < n; i++) {      // n+1 times
    for (j = 0; j < n; j++) {  // n*(n+1) times
        x = x + 1;             // n*n times
    }
}
                    </div>
                    <p><strong>Total Operations:</strong> (n+1) + n(n+1) + n¬≤ = 2n¬≤ + 2n + 1</p>
                    <p><strong>Time Complexity:</strong> O(n¬≤)</p>
                </div>
                
                <div class="formula">
                    T(n) = c‚ÇÅn¬≤ + c‚ÇÇn + c‚ÇÉ = O(n¬≤)
                </div>
                
                <p><strong>Best, Average, and Worst Case Analysis:</strong></p>
                <ul>
                    <li><strong>Best Case:</strong> Minimum time/space required (optimistic scenario)</li>
                    <li><strong>Average Case:</strong> Expected time/space over all possible inputs</li>
                    <li><strong>Worst Case:</strong> Maximum time/space required (pessimistic scenario)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">3. Asymptotic Notations: Big O, Omega, Theta</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üìà For a 5-Year-Old: What are Asymptotic Notations?</div>
                <p>Imagine you're growing a plant. Big O tells you "your plant won't grow taller than this tree." Omega tells you "your plant will grow at least as tall as this flower." Theta tells you "your plant will grow about as tall as this bush." These are just different ways to describe how big something gets!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üéØ Mathematical Definitions & Properties</div>
                <p><strong>Asymptotic Notations</strong> are mathematical tools used to describe the behavior of functions as their input approaches infinity. They provide a way to classify algorithms based on their growth rates.</p>
                
                <div class="svg-container">
                    <svg width="700" height="400" viewBox="0 0 700 400" xmlns="http://www.w3.org/2000/svg">
                        <!-- Big O Visualization -->
                        <g transform="translate(0, 0)">
                            <text x="350" y="30" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Big O Notation: f(n) = O(g(n))</text>
                            
                            <!-- Coordinate system -->
                            <line x1="50" y1="150" x2="650" y2="150" stroke="#2c3e50" stroke-width="1"/>
                            <line x1="50" y1="50" x2="50" y2="150" stroke="#2c3e50" stroke-width="1"/>
                            
                            <!-- g(n) = n¬≤ -->
                            <path d="M 50 140 Q 200 100, 350 60 T 650 50" stroke="#e74c3c" stroke-width="2" fill="none" stroke-dasharray="5,5"/>
                            <text x="660" y="55" font-size="12" fill="#e74c3c">g(n) = n¬≤</text>
                            
                            <!-- f(n) = 3n¬≤ + 2n + 1 -->
                            <path d="M 50 145 Q 200 110, 350 70 T 650 55" stroke="#3498db" stroke-width="3" fill="none"/>
                            <text x="660" y="60" font-size="12" fill="#3498db">f(n) = 3n¬≤ + 2n + 1</text>
                            
                            <!-- c*g(n) = 4n¬≤ -->
                            <path d="M 50 135 Q 200 90, 350 55 T 650 45" stroke="#27ae60" stroke-width="2" fill="none"/>
                            <text x="660" y="50" font-size="12" fill="#27ae60">c¬∑g(n) = 4n¬≤</text>
                            
                            <!-- n‚ÇÄ marker -->
                            <line x1="200" y1="50" x2="200" y2="150" stroke="#f39c12" stroke-width="2" stroke-dasharray="3,3"/>
                            <text x="200" y="165" text-anchor="middle" font-size="12" fill="#f39c12">n‚ÇÄ</text>
                        </g>
                        
                        <!-- Omega Visualization -->
                        <g transform="translate(0, 200)">
                            <text x="350" y="30" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Omega Notation: f(n) = Œ©(g(n))</text>
                            
                            <!-- Coordinate system -->
                            <line x1="50" y1="150" x2="650" y2="150" stroke="#2c3e50" stroke-width="1"/>
                            <line x1="50" y1="50" x2="50" y2="150" stroke="#2c3e50" stroke-width="1"/>
                            
                            <!-- g(n) = n -->
                            <path d="M 50 140 Q 350 100, 650 50" stroke="#e74c3c" stroke-width="2" fill="none" stroke-dasharray="5,5"/>
                            <text x="660" y="55" font-size="12" fill="#e74c3c">g(n) = n</text>
                            
                            <!-- f(n) = 2n + 3 -->
                            <path d="M 50 130 Q 350 80, 650 40" stroke="#3498db" stroke-width="3" fill="none"/>
                            <text x="660" y="45" font-size="12" fill="#3498db">f(n) = 2n + 3</text>
                            
                            <!-- c*g(n) = 1.5n -->
                            <path d="M 50 135 Q 350 90, 650 45" stroke="#27ae60" stroke-width="2" fill="none"/>
                            <text x="660" y="50" font-size="12" fill="#27ae60">c¬∑g(n) = 1.5n</text>
                            
                            <!-- n‚ÇÄ marker -->
                            <line x1="150" y1="50" x2="150" y2="150" stroke="#f39c12" stroke-width="2" stroke-dasharray="3,3"/>
                            <text x="150" y="165" text-anchor="middle" font-size="12" fill="#f39c12">n‚ÇÄ</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 4: Big O and Omega Notations Visualized</div>
                </div>
                
                <p><strong>Big O Notation (O):</strong> Upper bound</p>
                <div class="formula">
                    f(n) = O(g(n)) if ‚àÉ positive constants c and n‚ÇÄ such that 0 ‚â§ f(n) ‚â§ c¬∑g(n) for all n ‚â• n‚ÇÄ
                </div>
                
                <p><strong>Omega Notation (Œ©):</strong> Lower bound</p>
                <div class="formula">
                    f(n) = Œ©(g(n)) if ‚àÉ positive constants c and n‚ÇÄ such that 0 ‚â§ c¬∑g(n) ‚â§ f(n) for all n ‚â• n‚ÇÄ
                </div>
                
                <p><strong>Theta Notation (Œò):</strong> Tight bound</p>
                <div class="formula">
                    f(n) = Œò(g(n)) if ‚àÉ positive constants c‚ÇÅ, c‚ÇÇ, and n‚ÇÄ such that 0 ‚â§ c‚ÇÅ¬∑g(n) ‚â§ f(n) ‚â§ c‚ÇÇ¬∑g(n) for all n ‚â• n‚ÇÄ
                </div>
                
                <div class="example">
                    <div class="example-title">üìä Practical Example: Analyzing f(n) = 3n¬≤ + 2n + 1</div>
                    <p><strong>Big O:</strong> f(n) = O(n¬≤) because 3n¬≤ + 2n + 1 ‚â§ 4n¬≤ for n ‚â• 3</p>
                    <p><strong>Omega:</strong> f(n) = Œ©(n¬≤) because 3n¬≤ + 2n + 1 ‚â• 3n¬≤ for n ‚â• 1</p>
                    <p><strong>Theta:</strong> f(n) = Œò(n¬≤) because 3n¬≤ ‚â§ 3n¬≤ + 2n + 1 ‚â§ 4n¬≤ for n ‚â• 3</p>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">4. Recursion and its Applications</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üîÑ For a 5-Year-Old: What is Recursion?</div>
                <p>Imagine you have a Russian nesting doll. When you open it, you find a smaller doll inside. When you open that one, you find an even smaller doll! This keeps happening until you find the tiniest doll that can't be opened. Recursion is like this - a function that calls itself until it reaches the smallest version!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üß© Formal Definition & Implementation</div>
                <p><strong>Recursion</strong> is a programming technique where a function calls itself directly or indirectly to solve a problem by breaking it down into smaller, similar subproblems.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- Recursive Function Call Stack -->
                        <g transform="translate(50, 50)">
                            <text x="300" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Recursive Function Call Stack: factorial(4)</text>
                            
                            <!-- Stack frames -->
                            <rect x="100" y="30" width="400" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="55" text-anchor="middle" fill="white" font-weight="bold">factorial(4)</text>
                            <text x="300" y="75" text-anchor="middle" fill="white">return 4 * factorial(3)</text>
                            
                            <rect x="100" y="100" width="400" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="125" text-anchor="middle" fill="white" font-weight="bold">factorial(3)</text>
                            <text x="300" y="145" text-anchor="middle" fill="white">return 3 * factorial(2)</text>
                            
                            <rect x="100" y="170" width="400" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="195" text-anchor="middle" fill="white" font-weight="bold">factorial(2)</text>
                            <text x="300" y="215" text-anchor="middle" fill="white">return 2 * factorial(1)</text>
                            
                            <rect x="100" y="240" width="400" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="265" text-anchor="middle" fill="white" font-weight="bold">factorial(1)</text>
                            <text x="300" y="285" text-anchor="middle" fill="white">return 1 * factorial(0)</text>
                            
                            <!-- Base case -->
                            <rect x="100" y="310" width="400" height="60" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="335" text-anchor="middle" fill="white" font-weight="bold">factorial(0)</text>
                            <text x="300" y="355" text-anchor="middle" fill="white">return 1 (Base Case)</text>
                            
                            <!-- Arrows showing call flow -->
                            <path d="M 300 90 L 300 100" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 300 160 L 300 170" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 300 230 L 300 240" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 300 300 L 300 310" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Return arrows -->
                            <path d="M 450 340 L 450 280" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)" stroke-dasharray="3,3"/>
                            <path d="M 450 210 L 450 150" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)" stroke-dasharray="3,3"/>
                            <path d="M 450 140 L 450 80" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)" stroke-dasharray="3,3"/>
                            <path d="M 450 70 L 450 10" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)" stroke-dasharray="3,3"/>
                            
                            <!-- Arrow markers -->
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                                </marker>
                                <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                                </marker>
                            </defs>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 5: Recursive Function Call Stack for Factorial(4)</div>
                </div>
                
                <p><strong>Essential Components of Recursion:</strong></p>
                <ul>
                    <li><strong>Base Case:</strong> The condition that stops the recursion</li>
                    <li><strong>Recursive Case:</strong> The part where the function calls itself</li>
                    <li><strong>Call Stack:</strong> Memory stack that tracks function calls</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Recursive Factorial Implementation</div>
                    <div class="code">
function factorial(n) {
    // Base case
    if (n == 0 || n == 1) {
        return 1;
    }
    // Recursive case
    else {
        return n * factorial(n - 1);
    }
}
                    </div>
                    <p><strong>Time Complexity:</strong> O(n)</p>
                    <p><strong>Space Complexity:</strong> O(n) due to call stack</p>
                </div>
                
                <p><strong>Applications of Recursion:</strong></p>
                <ul>
                    <li><strong>Tree Traversal:</strong> Inorder, Preorder, Postorder</li>
                    <li><strong>Divide and Conquer:</strong> Merge Sort, Quick Sort</li>
                    <li><strong>Dynamic Programming:</strong> Fibonacci, Coin Change</li>
                    <li><strong>Graph Algorithms:</strong> DFS, Topological Sort</li>
                    <li><strong>Mathematical Computations:</strong> Factorial, Power, GCD</li>
                </ul>
                
                <div class="formula">
                    T(n) = T(n-1) + O(1) = O(n)  // For simple linear recursion
                </div>
                
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li>Elegant and concise code for complex problems</li>
                    <li>Natural fit for problems with recursive structure</li>
                    <li>Reduces code duplication</li>
                </ul>
                
                <p><strong>Disadvantages:</strong></p>
                <ul>
                    <li>Can be less efficient than iterative solutions</li>
                    <li>Risk of stack overflow for deep recursion</li>
                    <li>Can be harder to debug and understand</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">Module Summary & Exam Focus</h2>
        
        <div class="concept">
            <div class="deep-explanation">
                <div class="deep-title">üéØ Key Exam Topics from Module 1</div>
                
                <p><strong>High-Frequency Exam Questions:</strong></p>
                <ol>
                    <li><strong>Algorithm Analysis using Frequency Count:</strong>
                        <ul>
                            <li>Calculate time complexity of nested loops</li>
                            <li>Analyze recursive algorithms</li>
                            <li>Compare different algorithmic approaches</li>
                        </ul>
                    </li>
                    
                    <li><strong>Asymptotic Notations:</strong>
                        <ul>
                            <li>Prove Big O, Omega, Theta for given functions</li>
                            <li>Compare growth rates of different functions</li>
                            <li>Derive complexity bounds for algorithms</li>
                        </ul>
                    </li>
                    
                    <li><strong>ADT Implementation:</strong>
                        <ul>
                            <li>Design ADTs for specific problems</li>
                            <li>Compare different implementations</li>
                            <li>Analyze trade-offs between implementations</li>
                        </ul>
                    </li>
                    
                    <li><strong>Recursive Algorithm Design:</strong>
                        <ul>
                            <li>Write recursive solutions for problems</li>
                            <li>Analyze time and space complexity</li>
                            <li>Convert recursive to iterative solutions</li>
                        </ul>
                    </li>
                </ol>
                
                <div class="example">
                    <div class="example-title">üìù Sample Exam Question</div>
                    <p><strong>Question:</strong> Calculate the frequency count and time complexity of the following code segment:</p>
                    <div class="code">
for (i = 0; i < n; i++) {
    for (j = 0; j < i; j++) {
        for (k = 0; k < j; k++) {
            x = x + 1;
        }
    }
}
                    </div>
                    <p><strong>Solution Approach:</strong>
                    <br>1. Innermost loop (k): runs j times
                    <br>2. Middle loop (j): runs i times
                    <br>3. Outer loop (i): runs n times
                    <br>4. Total operations: Œ£(i=0 to n-1) Œ£(j=0 to i-1) j = Œ£(i=0 to n-1) i(i-1)/2 = O(n¬≥)</p>
                </div>
                
                <p><strong>Study Strategy:</strong></p>
                <ul>
                    <li>Master the frequency count method for complexity analysis</li>
                    <li>Practice proving asymptotic notations mathematically</li>
                    <li>Understand the relationship between data types and ADTs</li>
                    <li>Develop intuition for recursive problem-solving</li>
                    <li>Work through examples from previous year papers</li>
                </ul>
                
                <div class="formula">
                    Exam Success = Understanding + Practice + Application
                </div>
            </div>
        </div>
    </div>
        <div class="header">
        <h2 class="subtitle">Module 2: Arrays and Linked Lists</h2>
    </div>

    <div class="section">
        <h2 class="section-title">1. Linear Arrays</h2>
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">For a 5-Year-Old</div>
                <p>Imagine a row of numbered mailboxes. Each mailbox can hold one letter. You know exactly which mailbox is which because of its number. If you want to find the 5th letter, you just go straight to mailbox number 5. It's super fast! But if you want to add a new mailbox in the middle, you have to move all the other mailboxes down to make space, which is a lot of work.</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">The Deep Dive</div>
                <p>A <strong>Linear Array</strong> is a fundamental data structure consisting of a collection of elements of the same data type, stored in contiguous memory locations. Each element can be directly accessed by its index, which is an integer value, typically starting from 0.</p>
                <div class="formula">
                    Address(A[i]) = Base_Address + (i * Size_of_Element)
                </div>
                <p><strong>Key Characteristics:</strong></p>
                <ul>
                    <li><strong>Fixed Size:</strong> The size of an array is defined at the time of its declaration and cannot be changed during runtime.</li>
                    <li><strong>Homogeneous Elements:</strong> All elements in an array must be of the same type (e.g., all integers, all characters).</li>
                    <li><strong>Random Access:</strong> Elements can be accessed in constant time, O(1), using their index. This is the primary advantage of arrays.</li>
                    <li><strong>Contiguous Memory:</strong> Elements are stored next to each other in memory, which enables fast access.</li>
                </ul>
                <p><strong>Common Operations & Time Complexity:</strong></p>
                <ul>
                    <li><strong>Access (by index):</strong> O(1) - Direct calculation of memory address.</li>
                    <li><strong>Search (unsorted):</strong> O(n) - Requires checking each element sequentially (Linear Search).</li>
                    <li><strong>Search (sorted):</strong> O(log n) - Possible with algorithms like Binary Search.</li>
                    <li><strong>Insertion (at the end):</strong> O(1) - If space is available.</li>
                    <li><strong>Insertion (at the beginning/middle):</strong> O(n) - Requires shifting subsequent elements.</li>
                    <li><strong>Deletion (at the beginning/middle):</strong> O(n) - Requires shifting subsequent elements to fill the gap.</li>
                </ul>
                <div class="svg-container">
                    <svg width="500" height="120" viewBox="0 0 500 120">
                        <rect x="10" y="40" width="40" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                        <text x="30" y="65" text-anchor="middle" fill="white" font-family="Arial">10</text>
                        <text x="30" y="30" text-anchor="middle" fill="#2c3e50" font-family="Arial">0</text>

                        <rect x="50" y="40" width="40" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                        <text x="70" y="65" text-anchor="middle" fill="white" font-family="Arial">25</text>
                        <text x="70" y="30" text-anchor="middle" fill="#2c3e50" font-family="Arial">1</text>

                        <rect x="90" y="40" width="40" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                        <text x="110" y="65" text-anchor="middle" fill="white" font-family="Arial">5</text>
                        <text x="110" y="30" text-anchor="middle" fill="#2c3e50" font-family="Arial">2</text>

                        <rect x="130" y="40" width="40" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                        <text x="150" y="65" text-anchor="middle" fill="white" font-family="Arial">42</text>
                        <text x="150" y="30" text-anchor="middle" fill="#2c3e50" font-family="Arial">3</text>

                        <rect x="170" y="40" width="40" height="40" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                        <text x="190" y="65" text-anchor="middle" fill="white" font-family="Arial">99</text>
                        <text x="190" y="30" text-anchor="middle" fill="#2c3e50" font-family="Arial">4</text>
                        
                        <rect x="210" y="40" width="40" height="40" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2" stroke-dasharray="5,5"/>
                        <text x="230" y="30" text-anchor="middle" fill="#2c3e50" font-family="Arial">5</text>

                        <rect x="250" y="40" width="40" height="40" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2" stroke-dasharray="5,5"/>
                        <text x="270" y="30" text-anchor="middle" fill="#2c3e50" font-family="Arial">6</text>
                        
                        <text x="10" y="100" fill="#2c3e50" font-family="Arial">Index</text>
                        <text x="10" y="115" fill="#2c3e50" font-family="Arial">Value</text>

                        <path d="M 195 25 L 195 15 L 280 15 L 280 105 L 190 105 L 190 85" fill="none" stroke="#e74c3c" stroke-width="2"/>
                        <text x="237" y="12" text-anchor="middle" fill="#e74c3c" font-family="Arial">Insert 17 at index 4</text>
                    </svg>
                </div>
                <div class="svg-caption">Visualizing an array and the costly operation of inserting an element in the middle.</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">2. Sparse Matrices</h2>
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">For a 5-Year-Old</div>
                <p>Imagine a giant parking lot for 1000 cars, but only 5 cars are parked in it. It would be silly to draw a map of all 1000 empty parking spots, right? A sparse matrix is like a smart list that only writes down where the 5 cars are, like "Car A is in spot 12, Car B is in spot 45," and so on. It saves a lot of paper!</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">The Deep Dive</div>
                <p>A <strong>Sparse Matrix</strong> is a matrix in which most of the elements are zero. Storing such a matrix using a standard 2D array is inefficient as it wastes a significant amount of memory to store the zero values. Special representations are used to store only the non-zero elements.</p>
                <p><strong>Why Use Sparse Matrix Representations?</strong></p>
                <ul>
                    <li><strong>Memory Efficiency:</strong> Drastically reduces storage requirements, especially for matrices with a very high density of zeros.</li>
                    <li><strong>Computational Efficiency:</strong> Algorithms can be optimized to operate only on non-zero elements, saving processing time.</li>
                </ul>
                <p><strong>Common Representations:</strong></p>
                <ul>
                    <li><strong>Coordinate List (COO):</strong> Stores a list of tuples <code>(row, column, value)</code> for each non-zero element. This is simple but not always the most efficient for computations.</li>
                    <li><strong>Compressed Sparse Row (CSR):</strong> A more complex but efficient representation. It uses three arrays:
                        <ul>
                            <li><code>values</code>: Contains all non-zero values, row by row.</li>
                            <li><code>col_ind</code>: Contains the column index for each value in the <code>values</code> array.</li>
                            <li><code>row_ptr</code>: An array where <code>row_ptr[i]</code> points to the start of the i-th row in the <code>values</code> and <code>col_ind</code> arrays. Its size is <code>number_of_rows + 1</code>.</li>
                        </ul>
                    </li>
                </ul>
                <div class="svg-container">
                    <svg width="600" height="200" viewBox="0 0 600 200">
                        <!-- Standard Matrix -->
                        <text x="20" y="20" fill="#2c3e50" font-family="Arial" font-weight="bold">Standard 2D Array (Wasteful)</text>
                        <g transform="translate(20, 30)">
                            <rect x="0" y="0" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1"/>
                            <text x="15" y="20" text-anchor="middle" fill="#2c3e50" font-family="Arial">0</text>
                            <rect x="30" y="0" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1"/>
                            <text x="45" y="20" text-anchor="middle" fill="#2c3e50" font-family="Arial">0</text>
                            <rect x="60" y="0" width="30" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="20" text-anchor="middle" fill="white" font-family="Arial">5</text>
                            
                            <rect x="0" y="30" width="30" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="15" y="50" text-anchor="middle" fill="white" font-family="Arial">1</text>
                            <rect x="30" y="30" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1"/>
                            <text x="45" y="50" text-anchor="middle" fill="#2c3e50" font-family="Arial">0</text>
                            <rect x="60" y="30" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="50" text-anchor="middle" fill="#2c3e50" font-family="Arial">0</text>
                            
                            <rect x="0" y="60" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1"/>
                            <text x="15" y="80" text-anchor="middle" fill="#2c3e50" font-family="Arial">0</text>
                            <rect x="30" y="60" width="30" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="45" y="80" text-anchor="middle" fill="white" font-family="Arial">8</text>
                            <rect x="60" y="60" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="80" text-anchor="middle" fill="#2c3e50" font-family="Arial">0</text>
                        </g>
                        
                        <!-- Arrow -->
                        <path d="M 120 60 L 170 60" stroke="#e74c3c" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>

                        <!-- COO Representation -->
                        <text x="320" y="20" fill="#2c3e50" font-family="Arial" font-weight="bold">Coordinate List (COO)</text>
                        <g transform="translate(320, 30)">
                            <text x="0" y="20" fill="#2c3e50" font-family="Arial">Row:</text>
                            <rect x="40" y="5" width="25" height="25" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="52" y="22" text-anchor="middle" fill="white" font-family="Arial">0</text>
                            <rect x="65" y="5" width="25" height="25" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="77" y="22" text-anchor="middle" fill="white" font-family="Arial">1</text>
                            <rect x="90" y="5" width="25" height="25" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="102" y="22" text-anchor="middle" fill="white" font-family="Arial">2</text>

                            <text x="0" y="50" fill="#2c3e50" font-family="Arial">Col:</text>
                            <rect x="40" y="35" width="25" height="25" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="52" y="52" text-anchor="middle" fill="white" font-family="Arial">2</text>
                            <rect x="65" y="35" width="25" height="25" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="77" y="52" text-anchor="middle" fill="white" font-family="Arial">0</text>
                            <rect x="90" y="35" width="25" height="25" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="102" y="52" text-anchor="middle" fill="white" font-family="Arial">1</text>

                            <text x="0" y="80" fill="#2c3e50" font-family="Arial">Val:</text>
                            <rect x="40" y="65" width="25" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="52" y="82" text-anchor="middle" fill="white" font-family="Arial">5</text>
                            <rect x="65" y="65" width="25" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="77" y="82" text-anchor="middle" fill="white" font-family="Arial">1</text>
                            <rect x="90" y="65" width="25" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="102" y="82" text-anchor="middle" fill="white" font-family="Arial">8</text>
                        </g>
                    </svg>
                </div>
                <div class="svg-caption">Comparison of a standard 2D array representation with the efficient Coordinate List (COO) for a sparse matrix.</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">3. Stacks (LIFO)</h2>
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">For a 5-Year-Old</div>
                <p>Think of a stack of plates. You can only put a new plate on the very top. And when you want to take a plate, you can only take the one from the very top. The last plate you put on is the first one you take off. That's the rule!</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">The Deep Dive</div>
                <p>A <strong>Stack</strong> is a linear data structure that follows the <strong>Last-In, First-Out (LIFO)</strong> principle. It is an Abstract Data Type (ADT) used by most programming languages. The name "stack" comes from the analogy of a stack of plates in a cafeteria.</p>
                <p><strong>Core Operations:</strong></p>
                <ul>
                    <li><strong>push(item):</strong> Adds an element to the top of the stack.</li>
                    <li><strong>pop():</strong> Removes and returns the element from the top of the stack. Returns an error if the stack is empty (Stack Underflow).</li>
                    <li><strong>peek() or top():</strong> Returns the top element of the stack without removing it.</li>
                    <li><strong>isEmpty():</strong> Returns true if the stack is empty, false otherwise.</li>
                    <li><strong>isFull():</strong> (For array-based implementation) Returns true if the stack is full, false otherwise (Stack Overflow).</li>
                </ul>
                <p><strong>Applications of Stacks:</strong></p>
                <ul>
                    <li><strong>Expression Evaluation and Conversion:</strong> Used to evaluate postfix/prefix expressions and convert infix to postfix/prefix.</li>
                    <li><strong>Function Call Stack:</strong> When a function is called, its return address and local variables are "pushed" onto the call stack. When the function returns, they are "popped".</li>
                    <li><strong>Undo/Redo Functionality:</strong> In text editors or graphic design software, each action is pushed onto a stack. "Undo" pops the last action.</li>
                    <li><strong>Browser History:</strong> The "back" button can be implemented using a stack of visited URLs.</li>
                </ul>
                <div class="svg-container">
                    <svg width="300" height="250" viewBox="0 0 300 250">
                        <text x="150" y="20" text-anchor="middle" fill="#2c3e50" font-family="Arial" font-weight="bold">Stack Operations</text>
                        
                        <!-- Stack Representation -->
                        <rect x="100" y="40" width="100" height="150" fill="none" stroke="#2c3e50" stroke-width="2"/>
                        <text x="50" y="120" text-anchor="middle" fill="#2c3e50" font-family="Arial">Stack</text>

                        <!-- Elements -->
                        <rect x="100" y="140" width="100" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                        <text x="150" y="157" text-anchor="middle" fill="white" font-family="Arial">10</text>
                        
                        <rect x="100" y="115" width="100" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                        <text x="150" y="132" text-anchor="middle" fill="white" font-family="Arial">25</text>

                        <rect x="100" y="90" width="100" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                        <text x="150" y="107" text-anchor="middle" fill="white" font-family="Arial">5</text>
                        
                        <rect x="100" y="65" width="100" height="25" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                        <text x="150" y="82" text-anchor="middle" fill="white" font-family="Arial">99</text>

                        <!-- Top Pointer -->
                        <line x1="80" y1="77" x2="95" y2="77" stroke="#e74c3c" stroke-width="2" marker-end="url(#arrowhead2)"/>
                        <text x="40" y="82" text-anchor="middle" fill="#e74c3c" font-family="Arial" font-weight="bold">Top</text>
                        <defs>
                            <marker id="arrowhead2" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>
                        
                        <!-- Push/Pop Labels -->
                        <path d="M 150 210 L 150 195" stroke="#27ae60" stroke-width="2" marker-end="url(#arrowhead3)"/>
                        <text x="150" y="225" text-anchor="middle" fill="#27ae60" font-family="Arial" font-weight="bold">push(17)</text>
                        <defs>
                            <marker id="arrowhead3" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#27ae60"/>
                            </marker>
                        </defs>
                    </svg>
                </div>
                <div class="svg-caption">Visual representation of a stack with a 'Top' pointer and a 'push' operation.</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">4. Queues (FIFO)</h2>
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">For a 5-Year-Old</div>
                <p>Imagine you're in line for a ride at an amusement park. The first person who gets in line is the very first person to get on the ride. New people always join the line at the very back. You can't cut in front!</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">The Deep Dive</div>
                <p>A <strong>Queue</strong> is a linear data structure that follows the <strong>First-In, First-Out (FIFO)</strong> principle. Elements are inserted at one end (the <strong>rear</strong> or <strong>tail</strong>) and removed from the other end (the <strong>front</strong> or <strong>head</strong>). This is analogous to a real-world queue or line.</p>
                <p><strong>Core Operations:</strong></p>
                <ul>
                    <li><strong>enqueue(item):</strong> Adds an element to the rear of the queue.</li>
                    <li><strong>dequeue():</strong> Removes and returns the element from the front of the queue. Returns an error if the queue is empty (Queue Underflow).</li>
                    <li><strong>front() or peek():</strong> Returns the front element of the queue without removing it.</li>
                    <li><strong>rear():</strong> Returns the rear element of the queue without removing it.</li>
                    <li><strong>isEmpty():</strong> Returns true if the queue is empty, false otherwise.</li>
                    <li><strong>isFull():</strong> (For array-based implementation) Returns true if the queue is full (Queue Overflow).</li>
                </ul>
                <p><strong>Types of Queues:</strong></p>
                <ul>
                    <li><strong>Simple Queue:</strong> The basic FIFO structure. In an array implementation, it suffers from a problem where the queue appears "full" even when there's empty space at the beginning after several dequeues.</li>
                    <li><strong>Circular Queue:</strong> Solves the problem of the simple queue by connecting the end of the array back to its start, forming a circle. The rear and front pointers wrap around to the beginning when they reach the end. This reuses the empty space.</li>
                    <li><strong>Priority Queue:</strong> Each element has an associated priority. Elements with higher priority are dequeued before elements with lower priority, regardless of their insertion order.</li>
                    <li><strong>Double-Ended Queue (Deque):</strong> Elements can be inserted and removed from both the front and the rear.</li>
                </ul>
                <div class="svg-container">
                    <svg width="500" height="150" viewBox="0 0 500 150">
                        <text x="250" y="20" text-anchor="middle" fill="#2c3e50" font-family="Arial" font-weight="bold">Circular Queue</text>
                        
                        <!-- Circular Representation -->
                        <path d="M 150 70 A 50 50 0 1 1 250 70" fill="none" stroke="#2c3e50" stroke-width="2"/>
                        <path d="M 250 70 A 50 50 0 1 1 150 70" fill="none" stroke="#2c3e50" stroke-width="2" stroke-dasharray="5,5"/>
                        
                        <!-- Elements -->
                        <rect x="175" y="35" width="40" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                        <text x="195" y="52" text-anchor="middle" fill="white" font-family="Arial">A</text>
                        <rect x="225" y="35" width="40" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                        <text x="245" y="52" text-anchor="middle" fill="white" font-family="Arial">B</text>
                        <rect x="235" y="75" width="40" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                        <text x="255" y="92" text-anchor="middle" fill="white" font-family="Arial">C</text>
                        <rect x="175" y="85" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1" stroke-dasharray="5,5"/>
                        <text x="195" y="102" text-anchor="middle" fill="#2c3e50" font-family="Arial">D</text>
                        <rect x="125" y="75" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1" stroke-dasharray="5,5"/>
                        <text x="145" y="92" text-anchor="middle" fill="#2c3e50" font-family="Arial">E</text>
                        
                        <!-- Pointers -->
                        <line x1="195" y1="30" x2="195" y2="15" stroke="#e74c3c" stroke-width="2" marker-end="url(#arrowhead4)"/>
                        <text x="195" y="10" text-anchor="middle" fill="#e74c3c" font-family="Arial" font-weight="bold">Rear</text>
                        
                        <line x1="255" y1="105" x2="255" y2="120" stroke="#27ae60" stroke-width="2" marker-end="url(#arrowhead5)"/>
                        <text x="255" y="135" text-anchor="middle" fill="#27ae60" font-family="Arial" font-weight="bold">Front</text>
                        
                        <defs>
                            <marker id="arrowhead4" markerWidth="10" markerHeight="7" refX="5" refY="0" orient="auto">
                                <polygon points="0 7, 5 0, 10 7" fill="#e74c3c"/>
                            </marker>
                            <marker id="arrowhead5" markerWidth="10" markerHeight="7" refX="5" refY="7" orient="auto">
                                <polygon points="0 0, 5 7, 10 0" fill="#27ae60"/>
                            </marker>
                        </defs>

                        <!-- Linear Representation for clarity -->
                        <g transform="translate(320, 40)">
                            <text x="50" y="-10" text-anchor="middle" fill="#2c3e50" font-family="Arial" font-weight="bold">Linear View</text>
                            <rect x="0" y="0" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1" stroke-dasharray="5,5"/>
                            <text x="15" y="17" text-anchor="middle" fill="#2c3e50" font-family="Arial">E</text>
                            <rect x="30" y="0" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50" stroke-width="1" stroke-dasharray="5,5"/>
                            <text x="45" y="17" text-anchor="middle" fill="#2c3e50" font-family="Arial">D</text>
                            <rect x="60" y="0" width="30" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="17" text-anchor="middle" fill="white" font-family="Arial">A</text>
                            <rect x="90" y="0" width="30" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="105" y="17" text-anchor="middle" fill="white" font-family="Arial">B</text>
                            <rect x="120" y="0" width="30" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="135" y="17" text-anchor="middle" fill="white" font-family="Arial">C</text>
                            
                            <text x="75" y="50" text-anchor="middle" fill="#e74c3c" font-family="Arial" font-weight="bold">Rear</text>
                            <text x="75" y="65" text-anchor="middle" fill="#27ae60" font-family="Arial" font-weight="bold">Front</text>
                        </g>
                    </svg>
                </div>
                <div class="svg-caption">Visualizing a Circular Queue and its equivalent linear array representation, showing how the 'Front' and 'Rear' pointers wrap around.</div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">5. Linked Lists</h2>
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">For a 5-Year-Old</div>
                <p>A linked list is like a treasure hunt. You find the first clue (the "head"). That clue tells you where to find the second clue. The second clue tells you where the third one is, and so on. You can add a new clue anywhere by just changing the clue before it to point to the new one, and the new one points to the old next clue. You don't need to move any other clues!</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">The Deep Dive</div>
                <p>A <strong>Linked List</strong> is a linear data structure, but unlike arrays, its elements are not stored at contiguous memory locations. Instead, elements are linked using pointers. A linked list consists of nodes where each node contains a data field and a reference (or pointer) to the next node in the sequence.</p>
                <p><strong>The Node and Self-Referential Structures:</strong></p>
                <p>The fundamental building block of a linked list is the <strong>Node</strong>. A node is typically implemented using a <strong>self-referential structure</strong>, which is a structure that contains a pointer to a structure of its own type.</p>
                <div class="code">
struct Node {<br>
&nbsp;&nbsp;&nbsp;&nbsp;int data;<br>
&nbsp;&nbsp;&nbsp;&nbsp;struct Node* next; // Pointer to the next node<br>
};
                </div>
                <p><strong>Advantages over Arrays:</strong></p>
                <ul>
                    <li><strong>Dynamic Size:</strong> Linked lists can grow and shrink at runtime by allocating and deallocating memory. No need to know the size in advance.</li>
                    <li><strong>Efficient Insertions/Deletions:</strong> Adding or removing a node is efficient (O(1) if you have a pointer to the node) as it only involves updating a few pointers, unlike arrays which may require shifting many elements.</li>
                </ul>
                <p><strong>Disadvantages compared to Arrays:</strong></p>
                <ul>
                    <li><strong>Random Access is Not Allowed:</strong> To access an element at the n-th position, you must traverse the list from the head, one node at a time (O(n) time).</li>
                    <li><strong>Extra Memory Space:</strong> Each node requires extra space for the pointer.</li>
                    <li><strong>Poor Cache Locality:</strong> Since nodes are not in contiguous memory, there are more cache misses, which can lead to slower performance in some scenarios.</li>
                </ul>
                <div class="svg-container">
                    <svg width="600" height="180" viewBox="0 0 600 180">
                        <text x="300" y="20" text-anchor="middle" fill="#2c3e50" font-family="Arial" font-weight="bold">Singly Linked List Structure</text>
                        
                        <!-- Head Pointer -->
                        <rect x="20" y="60" width="60" height="30" fill="#95a5a6" stroke="#2c3e50" stroke-width="1"/>
                        <text x="50" y="80" text-anchor="middle" fill="white" font-family="Arial">Head</text>
                        <path d="M 80 75 L 100 75" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead6)"/>

                        <!-- Node 1 -->
                        <g transform="translate(100, 60)">
                            <rect x="0" y="0" width="50" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="25" y="20" text-anchor="middle" fill="white" font-family="Arial">10</text>
                            <rect x="50" y="0" width="50" height="30" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="20" text-anchor="middle" fill="white" font-family="Arial">Next</text>
                            <path d="M 100 15 L 120 15" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead6)"/>
                        </g>
                        
                        <!-- Node 2 -->
                        <g transform="translate(220, 60)">
                            <rect x="0" y="0" width="50" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="25" y="20" text-anchor="middle" fill="white" font-family="Arial">25</text>
                            <rect x="50" y="0" width="50" height="30" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="20" text-anchor="middle" fill="white" font-family="Arial">Next</text>
                            <path d="M 100 15 L 120 15" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead6)"/>
                        </g>

                        <!-- Node 3 -->
                        <g transform="translate(340, 60)">
                            <rect x="0" y="0" width="50" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="25" y="20" text-anchor="middle" fill="white" font-family="Arial">5</text>
                            <rect x="50" y="0" width="50" height="30" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="20" text-anchor="middle" fill="white" font-family="Arial">Next</text>
                        </g>
                        
                        <!-- NULL Pointer -->
                        <path d="M 440 75 L 480 75" stroke="#2c3e50" stroke-width="2"/>
                        <text x="490" y="80" fill="#2c3e50" font-family="Arial">NULL</text>
                        
                        <defs>
                            <marker id="arrowhead6" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                            </marker>
                        </defs>
                        
                        <!-- Labels -->
                        <text x="150" y="120" text-anchor="middle" fill="#2c3e50" font-family="Arial">Node 1</text>
                        <text x="270" y="120" text-anchor="middle" fill="#2c3e50" font-family="Arial">Node 2</text>
                        <text x="390" y="120" text-anchor="middle" fill="#2c3e50" font-family="Arial">Node 3</text>
                        <text x="125" y="140" text-anchor="middle" fill="#3498db" font-family="Arial">Data</text>
                        <text x="175" y="140" text-anchor="middle" fill="#e67e22" font-family="Arial">Pointer</text>
                    </svg>
                </div>
                <div class="svg-caption">Anatomy of a Singly Linked List, showing the Head pointer, individual nodes with Data and Next parts, and the terminating NULL pointer.</div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h2 class="section-title">6. Linked List Variations</h2>
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">For a 5-Year-Old</div>
                <p><strong>Doubly:</strong> Imagine a two-way street. Each house (node) knows the house to its right AND the house to its left. You can walk forward or backward.</p>
                <p><strong>Circular:</strong> Imagine a group of friends holding hands in a circle. The last friend is holding the first friend's hand. If you start walking, you'll eventually get back to where you started.</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">The Deep Dive</div>
                <p><strong>Singly vs. Doubly vs. Circular Linked Lists:</strong></p>
                <ul>
                    <li><strong>Singly Linked List:</strong> Traversal is only possible in one direction (forward). Each node points only to its successor.</li>
                    <li><strong>Doubly Linked List:</strong> Each node contains two pointers: one to the next node and one to the previous node. This allows for traversal in both directions (forward and backward). It requires more memory per node but simplifies certain operations like deletion.</li>
                    <li><strong>Circular Linked List:</strong> Can be a variation of singly or doubly linked lists. The 'next' pointer of the last node points back to the head node instead of being NULL. This forms a circle. It is useful in applications where you need to cycle through the elements repeatedly, such as in operating system task schedulers or multiplayer game turn management.</li>
                </ul>
                <div class="svg-container">
                    <svg width="650" height="220" viewBox="0 0 650 220">
                        <!-- Doubly Linked List -->
                        <text x="150" y="20" text-anchor="middle" fill="#2c3e50" font-family="Arial" font-weight="bold">Doubly Linked List</text>
                        <g transform="translate(50, 40)">
                            <rect x="0" y="0" width="40" height="25" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="20" y="17" text-anchor="middle" fill="white" font-family="Arial">Prev</text>
                            <rect x="40" y="0" width="40" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="60" y="17" text-anchor="middle" fill="white" font-family="Arial">10</text>
                            <rect x="80" y="0" width="40" height="25" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="100" y="17" text-anchor="middle" fill="white" font-family="Arial">Next</text>
                            <path d="M 120 12 L 140 12" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead7)"/>
                        </g>
                        <g transform="translate(170, 40)">
                            <rect x="0" y="0" width="40" height="25" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="20" y="17" text-anchor="middle" fill="white" font-family="Arial">Prev</text>
                            <rect x="40" y="0" width="40" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="60" y="17" text-anchor="middle" fill="white" font-family="Arial">25</text>
                            <rect x="80" y="0" width="40" height="25" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="100" y="17" text-anchor="middle" fill="white" font-family="Arial">Next</text>
                        </g>
                        <path d="M 190 52 L 210 52" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead7)"/>
                        <path d="M 170 52 L 150 52" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead7)"/>
                        <text x="130" y="90" text-anchor="middle" fill="#2c3e50" font-family="Arial">NULL</text>
                        <text x="290" y="90" text-anchor="middle" fill="#2c3e50" font-family="Arial">NULL</text>
                        <path d="M 290 52 L 310 52" stroke="#2c3e50" stroke-width="2"/>
                        <path d="M 130 52 L 110 52" stroke="#2c3e50" stroke-width="2"/>
                        
                        <!-- Circular Linked List -->
                        <text x="450" y="20" text-anchor="middle" fill="#2c3e50" font-family="Arial" font-weight="bold">Circular Linked List</text>
                        <g transform="translate(350, 40)">
                            <rect x="0" y="0" width="50" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="25" y="17" text-anchor="middle" fill="white" font-family="Arial">10</text>
                            <rect x="50" y="0" width="50" height="25" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="17" text-anchor="middle" fill="white" font-family="Arial">Next</text>
                            <path d="M 100 12 L 120 12" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead7)"/>
                        </g>
                        <g transform="translate(470, 40)">
                            <rect x="0" y="0" width="50" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="25" y="17" text-anchor="middle" fill="white" font-family="Arial">25</text>
                            <rect x="50" y="0" width="50" height="25" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="17" text-anchor="middle" fill="white" font-family="Arial">Next</text>
                            <path d="M 100 12 L 120 12" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead7)"/>
                        </g>
                        <g transform="translate(590, 40)">
                            <rect x="0" y="0" width="50" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="25" y="17" text-anchor="middle" fill="white" font-family="Arial">5</text>
                            <rect x="50" y="0" width="50" height="25" fill="#e67e22" stroke="#2c3e50" stroke-width="1"/>
                            <text x="75" y="17" text-anchor="middle" fill="white" font-family="Arial">Next</text>
                        </g>
                        <!-- Circular Arrow -->
                        <path d="M 640 52 Q 660 80, 640 110 Q 620 140, 590 140 Q 450 140, 430 110 Q 410 80, 430 52 Q 450 30, 475 30" fill="none" stroke="#e74c3c" stroke-width="2" marker-end="url(#arrowhead8)"/>
                        <defs>
                            <marker id="arrowhead7" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                            </marker>
                            <marker id="arrowhead8" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>
                        <text x="450" y="160" text-anchor="middle" fill="#e74c3c" font-family="Arial">Last node points to first</text>
                    </svg>
                </div>
                <div class="svg-caption">Visual comparison of Doubly Linked List (bidirectional pointers) and Circular Linked List (last node points to the first).</div>
            </div>
        </div>
    </div>
    <div class="header">
        <div class="subtitle">Module 3: Trees</div>
    </div>

    <div class="section">
        <h2 class="section-title">1. Introduction to Trees and Basic Terminology</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">Imagine a Family Tree...</div>
                <p>Think of a tree like your family tree. At the very top is your grandparent (the <strong>root</strong>). Your parent is a <strong>child</strong> of the grandparent. You are a child of your parent. You and your siblings are at the same level. People who don't have any children yet are at the very ends, like <strong>leaves</strong> on a real tree. It's just a way to connect things in a hierarchy, with one main starting point at the top.</p>
            </div>
            <div class="svg-container">
                <svg width="400" height="250" viewBox="0 0 400 250" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="200" cy="30" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                    <text x="200" y="35" text-anchor="middle" fill="white" font-size="12px">G</text>
                    <text x="200" y="10" text-anchor="middle" fill="#2c3e50" font-size="11px" font-style="italic">Root</text>
                    
                    <line x1="200" y1="45" x2="120" y2="85" stroke="#2c3e50" stroke-width="2"/>
                    <line x1="200" y1="45" x2="280" y2="85" stroke="#2c3e50" stroke-width="2"/>
                    
                    <circle cx="120" cy="100" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                    <text x="120" y="105" text-anchor="middle" fill="white" font-size="12px">P</text>
                    <text x="120" y="80" text-anchor="middle" fill="#2c3e50" font-size="11px" font-style="italic">Parent</text>

                    <circle cx="280" cy="100" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                    <text x="280" y="105" text-anchor="middle" fill="white" font-size="12px">A</text>
                    <text x="280" y="80" text-anchor="middle" fill="#2c3e50" font-size="11px" font-style="italic">Parent</text>

                    <line x1="120" y1="115" x2="80" y2="155" stroke="#2c3e50" stroke-width="2"/>
                    <line x1="120" y1="115" x2="160" y2="155" stroke="#2c3e50" stroke-width="2"/>
                    
                    <circle cx="80" cy="170" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                    <text x="80" y="175" text-anchor="middle" fill="white" font-size="12px">Y</text>
                    <text x="80" y="195" text-anchor="middle" fill="#2c3e50" font-size="11px" font-style="italic">Leaf</text>

                    <circle cx="160" cy="170" r="15" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                    <text x="160" y="175" text-anchor="middle" fill="white" font-size="12px">S</text>
                    <text x="160" y="195" text-anchor="middle" fill="#2c3e50" font-size="11px" font-style="italic">Child</text>
                    <text x="120" y="145" text-anchor="middle" fill="#2c3e50" font-size="11px" font-style="italic">Sibling</text>
                </svg>
                <div class="svg-caption">Figure 1: A tree diagram showing root, parent, child, sibling, and leaf nodes.</div>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Formal Definition and Terminology</div>
                <p>A <strong>Tree</strong> is a non-linear, hierarchical data structure consisting of nodes connected by edges. It has one unique top-most node called the <strong>root</strong>. Each node (except the root) is connected by a single directed edge from exactly one other node, its <strong>parent</strong>. A node may have zero or more <strong>children</strong>. Nodes with the same parent are called <strong>siblings</strong>. A node with no children is a <strong>leaf</strong> or <strong>external node</strong>. Nodes with at least one child are <strong>internal nodes</strong>.</p>
                <p>The <strong>level</strong> of a node is the number of edges on the unique path from the root to that node. The root is at level 0. The <strong>height</strong> of a node is the number of edges on the longest path from that node to a leaf. The <strong>height of the tree</strong> is the height of the root. The <strong>depth</strong> of a node is the number of edges from the node to the tree's root node.</p>
                <p><strong>Edge Cases & Properties:</strong> A tree with `n` nodes will always have exactly `n-1` edges. A single node by itself is a valid tree. An empty structure (no nodes) is often considered an empty tree.</p>
                <p><strong>Real-World Links:</strong> File systems on computers (directories and subdirectories), the DOM (Document Object Model) in web browsers, organizational charts, and XML/JSON data parsing all rely on tree structures.</p>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">2. Binary Trees</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">A "Yes/No" Decision Tree</div>
                <p>A binary tree is a special kind of tree where every rule-maker (every parent node) can make at most two decisions. Think of a "20 Questions" game. Each question can only lead to a "yes" path or a "no" path. It's a tree where each person can have at most two children. We call them the "left child" and the "right child".</p>
            </div>
            <div class="svg-container">
                <svg width="500" height="180" viewBox="0 0 500 180" xmlns="http://www.w3.org/2000/svg">
                    <!-- Binary Tree -->
                    <text x="125" y="15" text-anchor="middle" fill="#2c3e50" font-size="14px" font-weight="bold">Binary Tree</text>
                    <circle cx="125" cy="40" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                    <line x1="125" y1="55" x2="85" y2="85" stroke="#2c3e50" stroke-width="2"/>
                    <line x1="125" y1="55" x2="165" y2="85" stroke="#2c3e50" stroke-width="2"/>
                    <circle cx="85" cy="100" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                    <circle cx="165" cy="100" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                    
                    <!-- Non-Binary Tree -->
                    <text x="375" y="15" text-anchor="middle" fill="#2c3e50" font-size="14px" font-weight="bold">Non-Binary Tree</text>
                    <circle cx="375" cy="40" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                    <line x1="375" y1="55" x2="320" y2="85" stroke="#2c3e50" stroke-width="2"/>
                    <line x1="375" y1="55" x2="375" y2="85" stroke="#2c3e50" stroke-width="2"/>
                    <line x1="375" y1="55" x2="430" y2="85" stroke="#2c3e50" stroke-width="2"/>
                    <circle cx="320" cy="100" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                    <circle cx="375" cy="100" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                    <circle cx="430" cy="100" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                </svg>
                <div class="svg-caption">Figure 2: Comparison of a Binary Tree (max 2 children) and a Non-Binary Tree.</div>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Formal Definition, Properties, and Representation</div>
                <p>A <strong>Binary Tree</strong> is a tree data structure in which each node has at most two children, referred to as the <strong>left child</strong> and the <strong>right child</strong>. The distinction between left and right is significant, even if a node only has one child.</p>
                <p><strong>Key Properties:</strong></p>
                <div class="formula">Maximum nodes at level i = 2<sup>i</sup></div>
                <div class="formula">Maximum nodes in a tree of height h = 2<sup>(h+1)</sup> - 1</div>
                <p><strong>Proof of Max Nodes at Level i:</strong> By induction. Base case: Level 0 has 2^0 = 1 node (the root). Inductive step: Assume level `i` has 2^i nodes. Since each node can have at most 2 children, the next level, `i+1`, will have at most 2 * 2^i = 2^(i+1) nodes. QED.</p>
                <p><strong>Representation:</strong></p>
                <ul>
                    <li><strong>Linked Representation (using pointers):</strong> Each node is a structure containing a data field and two pointers: `leftChild` and `rightChild`. This is flexible and works for any binary tree shape.</li>
                    <li><strong>Array Representation:</strong> Efficient for <strong>complete binary trees</strong>. The root is at index 0. For a node at index `i`:
                        <ul>
                            <li>Parent is at index `floor((i-1)/2)`</li>
                            <li>Left child is at index `2i + 1`</li>
                            <li>Right child is at index `2i + 2`</li>
                        </ul>
                        This representation wastes space for sparse trees but is cache-friendly.
                    </li>
                </ul>
                <div class="svg-container">
                    <svg width="450" height="200" viewBox="0 0 450 200" xmlns="http://www.w3.org/2000/svg">
                        <text x="225" y="15" text-anchor="middle" fill="#2c3e50" font-size="14px" font-weight="bold">Array Representation of a Complete Binary Tree</text>
                        <!-- Tree -->
                        <g transform="translate(50, 40)">
                            <circle cx="60" cy="20" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                            <text x="60" y="25" text-anchor="middle" fill="white" font-size="10px">A</text>
                            <line x1="60" y1="32" x2="30" y2="58" stroke="#2c3e50" stroke-width="1.5"/>
                            <line x1="60" y1="32" x2="90" y2="58" stroke="#2c3e50" stroke-width="1.5"/>
                            <circle cx="30" cy="70" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                            <text x="30" y="75" text-anchor="middle" fill="white" font-size="10px">B</text>
                            <circle cx="90" cy="70" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                            <text x="90" y="75" text-anchor="middle" fill="white" font-size="10px">C</text>
                            <line x1="30" y1="82" x2="15" y2="108" stroke="#2c3e50" stroke-width="1.5"/>
                            <line x1="30" y1="82" x2="45" y2="108" stroke="#2c3e50" stroke-width="1.5"/>
                            <circle cx="15" cy="120" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                            <text x="15" y="125" text-anchor="middle" fill="white" font-size="10px">D</text>
                            <circle cx="45" cy="120" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                            <text x="45" y="125" text-anchor="middle" fill="white" font-size="10px">E</text>
                        </g>
                        <!-- Array -->
                        <g transform="translate(230, 60)">
                            <text x="0" y="-5" fill="#2c3e50" font-size="12px">Array:</text>
                            <rect x="0" y="0" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="15" y="17" text-anchor="middle" fill="#2c3e50" font-size="11px">A</text>
                            <text x="15" y="40" text-anchor="middle" fill="#7f8c8d" font-size="10px">[0]</text>

                            <rect x="35" y="0" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="50" y="17" text-anchor="middle" fill="#2c3e50" font-size="11px">B</text>
                            <text x="50" y="40" text-anchor="middle" fill="#7f8c8d" font-size="10px">[1]</text>

                            <rect x="70" y="0" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="85" y="17" text-anchor="middle" fill="#2c3e50" font-size="11px">C</text>
                            <text x="85" y="40" text-anchor="middle" fill="#7f8c8d" font-size="10px">[2]</text>

                            <rect x="105" y="0" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="120" y="17" text-anchor="middle" fill="#2c3e50" font-size="11px">D</text>
                            <text x="120" y="40" text-anchor="middle" fill="#7f8c8d" font-size="10px">[3]</text>
                            
                            <rect x="140" y="0" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="155" y="17" text-anchor="middle" fill="#2c3e50" font-size="11px">E</text>
                            <text x="155" y="40" text-anchor="middle" fill="#7f8c8d" font-size="10px">[4]</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 3: Mapping a complete binary tree to an array.</div>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">3. Tree Traversal Algorithms</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">How to Visit Every Room in a Castle</div>
                <p>Imagine you're in a castle (the root) and want to visit every room. There are three main ways to do it systematically:</p>
                <ul>
                    <li><strong>Pre-order:</strong> You visit the room you're in FIRST (take a photo), then explore the entire left tower, then explore the entire right tower. (Root -> Left -> Right)</li>
                    <li><strong>In-order:</strong> You explore the entire left tower FIRST, then visit the main room, then explore the right tower. (Left -> Root -> Right)</li>
                    <li><strong>Post-order:</strong> You explore the left tower FIRST, then the right tower, and ONLY when you're done with both do you visit the main room. (Left -> Right -> Root)</li>
                </ul>
            </div>
            <div class="svg-container">
                <svg width="500" height="350" viewBox="0 0 500 350" xmlns="http://www.w3.org/2000/svg">
                    <text x="250" y="15" text-anchor="middle" fill="#2c3e50" font-size="14px" font-weight="bold">Traversal Orders on the Same Tree</text>
                    <!-- Tree -->
                    <g transform="translate(50, 40)">
                        <circle cx="60" cy="20" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                        <text x="60" y="25" text-anchor="middle" fill="white" font-size="10px">F</text>
                        <line x1="60" y1="32" x2="30" y2="58" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="60" y1="32" x2="90" y2="58" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="30" cy="70" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                        <text x="30" y="75" text-anchor="middle" fill="white" font-size="10px">B</text>
                        <circle cx="90" cy="70" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                        <text x="90" y="75" text-anchor="middle" fill="white" font-size="10px">G</text>
                        <line x1="30" y1="82" x2="15" y2="108" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="30" y1="82" x2="45" y2="108" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="15" cy="120" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                        <text x="15" y="125" text-anchor="middle" fill="white" font-size="10px">A</text>
                        <circle cx="45" cy="120" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                        <text x="45" y="125" text-anchor="middle" fill="white" font-size="10px">D</text>
                        <line x1="90" y1="82" x2="90" y2="108" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="90" cy="120" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                        <text x="90" y="125" text-anchor="middle" fill="white" font-size="10px">I</text>
                        <line x1="45" y1="132" x2="35" y2="158" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="45" y1="132" x2="55" y2="158" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="35" cy="170" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                        <text x="35" y="175" text-anchor="middle" fill="white" font-size="10px">C</text>
                        <circle cx="55" cy="170" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                        <text x="55" y="175" text-anchor="middle" fill="white" font-size="10px">E</text>
                    </g>
                    <!-- Results -->
                    <g transform="translate(230, 60)">
                        <text x="0" y="0" fill="#27ae60" font-size="12px" font-weight="bold">Pre-order:</text>
                        <text x="0" y="18" fill="#2c3e50" font-size="11px">F -> B -> A -> D -> C -> E -> G -> I</text>
                        
                        <text x="0" y="50" fill="#e67e22" font-size="12px" font-weight="bold">In-order:</text>
                        <text x="0" y="68" fill="#2c3e50" font-size="11px">A -> B -> C -> D -> E -> F -> G -> I</text>

                        <text x="0" y="100" fill="#9b59b6" font-size="12px" font-weight="bold">Post-order:</text>
                        <text x="0" y="118" fill="#2c3e50" font-size="11px">A -> C -> E -> D -> B -> I -> G -> F</text>
                    </g>
                </svg>
                <div class="svg-caption">Figure 4: Pre-order, In-order, and Post-order traversal paths and outputs.</div>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Algorithms and Applications</div>
                <p>Tree traversal is the process of visiting (checking and/or updating) each node in a tree data structure, exactly once. These traversals are typically defined recursively.</p>
                <div class="code">
Algorithm PreOrder(node):
    if node is null, return
    print(node.data)           // Process
    PreOrder(node.left)        // Recurse on left
    PreOrder(node.right)       // Recurse on right

Algorithm InOrder(node):
    if node is null, return
    InOrder(node.left)         // Recurse on left
    print(node.data)           // Process
    InOrder(node.right)        // Recurse on right

Algorithm PostOrder(node):
    if node is null, return
    PostOrder(node.left)       // Recurse on left
    PostOrder(node.right)      // Recurse on right
    print(node.data)           // Process
                </div>
                <div class="example">
                    <div class="example-title">Example: In-Order Traversal on the tree in Figure 4</div>
                    <p>1. Start at root F. Go left to B. Go left to A. A has no left child. Process A. A has no right child. Return to B.</p>
                    <p>2. Process B. Go right to D. Go left to C. C has no left child. Process C. C has no right child. Return to D.</p>
                    <p>3. Process D. Go right to E. E has no left child. Process E. E has no right child. Return to D, then B, then F.</p>
                    <p>4. Process F. Go right to G. G has no left child. Process G. Go right to I. I has no left child. Process I. I has no right child. Return.</p>
                    <p><strong>Final Output: A, B, C, D, E, F, G, I</strong></p>
                </div>
                <p><strong>Applications:</strong></p>
                <ul>
                    <li><strong>In-order:</strong> For a Binary Search Tree (BST), this traversal visits nodes in ascending sorted order. Used to get sorted data from a BST.</li>
                    <li><strong>Pre-order:</strong> Used to create a copy of a tree. Also useful for prefix notation (Polish notation) in expression trees.</li>
                    <li><strong>Post-order:</strong> Used to delete a tree (must delete children before the parent). Also useful for postfix notation (Reverse Polish notation) in expression trees.</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">4. Binary Search Trees (BST)</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">A Super-Organized Bookshelf</div>
                <p>A Binary Search Tree is like a bookshelf where every book is placed according to a strict rule. The main book on the top shelf is the root. Any book on the left shelf must have a title that comes BEFORE the main book's title alphabetically. Any book on the right shelf must have a title that comes AFTER. This rule applies to every single shelf. This makes finding a book incredibly fast! You just look at a book, and you instantly know which half of the shelf to ignore.</p>
            </div>
            <div class="svg-container">
                <svg width="500" height="200" viewBox="0 0 500 200" xmlns="http://www.w3.org/2000/svg">
                    <text x="250" y="15" text-anchor="middle" fill="#2c3e50" font-size="14px" font-weight="bold">Binary Search Tree Property</text>
                    <!-- Valid BST -->
                    <g transform="translate(50, 40)">
                        <text x="60" y="-5" text-anchor="middle" fill="#27ae60" font-size="12px" font-weight="bold">Valid BST</text>
                        <circle cx="60" cy="20" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                        <text x="60" y="25" text-anchor="middle" fill="white" font-size="12px">50</text>
                        <line x1="60" y1="35" x2="25" y2="70" stroke="#2c3e50" stroke-width="2"/>
                        <line x1="60" y1="35" x2="95" y2="70" stroke="#2c3e50" stroke-width="2"/>
                        <circle cx="25" cy="85" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                        <text x="25" y="90" text-anchor="middle" fill="white" font-size="12px">30</text>
                        <circle cx="95" cy="85" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                        <text x="95" y="90" text-anchor="middle" fill="white" font-size="12px">70</text>
                        <text x="10" y="115" fill="#27ae60" font-size="10px">&lt; 50</text>
                        <text x="110" y="115" fill="#27ae60" font-size="10px">&gt; 50</text>
                    </g>
                    <!-- Invalid BST -->
                    <g transform="translate(250, 40)">
                        <text x="60" y="-5" text-anchor="middle" fill="#e74c3c" font-size="12px" font-weight="bold">Invalid BST</text>
                        <circle cx="60" cy="20" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                        <text x="60" y="25" text-anchor="middle" fill="white" font-size="12px">50</text>
                        <line x1="60" y1="35" x2="25" y2="70" stroke="#2c3e50" stroke-width="2"/>
                        <line x1="60" y1="35" x2="95" y2="70" stroke="#2c3e50" stroke-width="2"/>
                        <circle cx="25" cy="85" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                        <text x="25" y="90" text-anchor="middle" fill="white" font-size="12px">80</text>
                        <circle cx="95" cy="85" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                        <text x="95" y="90" text-anchor="middle" fill="white" font-size="12px">70</text>
                        <text x="5" y="115" fill="#e74c3c" font-size="10px">Error!</text>
                        <text x="5" y="128" fill="#e74c3c" font-size="10px">80 is not &lt; 50</text>
                    </g>
                </svg>
                <div class="svg-caption">Figure 5: A valid BST vs. an invalid one, demonstrating the core property.</div>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Properties, Insertion, and Deletion</div>
                <p>A <strong>Binary Search Tree (BST)</strong> is a binary tree with a special ordering property: for any given node `N`, all values in its left subtree are less than `N`'s value, and all values in its right subtree are greater than `N`'s value. (Assuming no duplicate keys for simplicity). This property allows for efficient searching, insertion, and deletion, typically with an average time complexity of O(log n).</p>
                
                <div class="example">
                    <div class="example-title">Insertion Algorithm & Example</div>
                    <p>To insert a value, start at the root. If the tree is empty, the new value becomes the root. Otherwise, compare the new value with the current node. If it's smaller, go left; if larger, go right. Repeat until you find an empty spot (a null child pointer) and insert the new node there.</p>
                    <div class="code">
Algorithm Insert(node, key):
    if node is null:
        return new Node(key)
    if key < node.data:
        node.left = Insert(node.left, key)
    else if key > node.data:
        node.right = Insert(node.right, key)
    return node
                    </div>
                    <p><strong>Example: Insert 60, 40, 70, 20, 50 into an empty BST.</strong></p>
                    <p>1. 60 becomes root. 2. 40 is < 60, goes left. 3. 70 is > 60, goes right. 4. 20 is < 60, go left. 20 is < 40, goes left. 5. 50 is < 60, go left. 50 is > 40, goes right.</p>
                </div>

                <div class="example">
                    <div class="example-title">Deletion Algorithm & Cases</div>
                    <p>Deleting a node is more complex and has three cases:</p>
                    <ol>
                        <li><strong>Node is a leaf (no children):</strong> Simply remove it by setting its parent's pointer to null.</li>
                        <li><strong>Node has one child:</strong> Bypass the node by connecting its parent directly to its single child.</li>
                        <li><strong>Node has two children:</strong> This is the tricky case. Find the node's <strong>in-order successor</strong> (the smallest value in its right subtree) or <strong>in-order predecessor</strong> (the largest value in its left subtree). Copy the successor's value to the node to be deleted, then delete the successor node (which is guaranteed to be in case 1 or 2).</li>
                    </ol>
                    <div class="svg-container">
                        <svg width="500" height="180" viewBox="0 0 500 180" xmlns="http://www.w3.org/2000/svg">
                            <text x="250" y="15" text-anchor="middle" fill="#2c3e50" font-size="12px" font-weight="bold">Deleting Node '50' (Case 3: Two Children)</text>
                            <!-- Before -->
                            <g transform="translate(50, 30)">
                                <text x="60" y="0" text-anchor="middle" fill="#2c3e50" font-size="11px">Before</text>
                                <circle cx="60" cy="20" r="12" fill="#e74c3c" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="60" y="25" text-anchor="middle" fill="white" font-size="10px">50</text>
                                <line x1="60" y1="32" x2="30" y2="58" stroke="#2c3e50" stroke-width="1.5"/>
                                <line x1="60" y1="32" x2="90" y2="58" stroke="#2c3e50" stroke-width="1.5"/>
                                <circle cx="30" cy="70" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="30" y="75" text-anchor="middle" fill="white" font-size="10px">30</text>
                                <circle cx="90" cy="70" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="90" y="75" text-anchor="middle" fill="white" font-size="10px">70</text>
                                <line x1="90" y1="82" x2="75" y2="108" stroke="#2c3e50" stroke-width="1.5"/>
                                <line x1="90" y1="82" x2="105" y2="108" stroke="#2c3e50" stroke-width="1.5"/>
                                <circle cx="75" cy="120" r="12" fill="#f39c12" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="75" y="125" text-anchor="middle" fill="white" font-size="10px">60</text>
                                <circle cx="105" cy="120" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="105" y="125" text-anchor="middle" fill="white" font-size="10px">80</text>
                                <text x="75" y="145" text-anchor="middle" fill="#f39c12" font-size="9px">Successor</text>
                            </g>
                            <!-- Arrow -->
                            <text x="220" y="100" text-anchor="middle" fill="#2c3e50" font-size="24px">‚Üí</text>
                            <!-- After -->
                            <g transform="translate(280, 30)">
                                <text x="60" y="0" text-anchor="middle" fill="#2c3e50" font-size="11px">After</text>
                                <circle cx="60" cy="20" r="12" fill="#f39c12" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="60" y="25" text-anchor="middle" fill="white" font-size="10px">60</text>
                                <line x1="60" y1="32" x2="30" y2="58" stroke="#2c3e50" stroke-width="1.5"/>
                                <line x1="60" y1="32" x2="90" y2="58" stroke="#2c3e50" stroke-width="1.5"/>
                                <circle cx="30" cy="70" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="30" y="75" text-anchor="middle" fill="white" font-size="10px">30</text>
                                <circle cx="90" cy="70" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="90" y="75" text-anchor="middle" fill="white" font-size="10px">70</text>
                                <line x1="90" y1="82" x2="105" y2="108" stroke="#2c3e50" stroke-width="1.5"/>
                                <circle cx="105" cy="120" r="12" fill="#3498db" stroke="#2c3e50" stroke-width="1.5"/>
                                <text x="105" y="125" text-anchor="middle" fill="white" font-size="10px">80</text>
                            </g>
                        </svg>
                        <div class="svg-caption">Figure 6: Deleting a node with two children by replacing it with its in-order successor.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="section">
        <h2 class="section-title">5. Full vs. Complete Binary Trees</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">Perfectly Packed vs. Perfectly Filled</div>
                <p>A <strong>Full</strong> binary tree is like a family where every parent has exactly two children. No one has just one child. It's very strict.</p>
                <p>A <strong>Complete</strong> binary tree is like filling seats in a theater row by row. You fill all the seats in the front row completely before moving to the next. And within a row, you fill from left to right, with no empty seats in the middle. The last row might not be full, but any empty seats must be to the far right.</p>
            </div>
            <div class="svg-container">
                <svg width="550" height="250" viewBox="0 0 550 250" xmlns="http://www.w3.org/2000/svg">
                    <text x="275" y="15" text-anchor="middle" fill="#2c3e50" font-size="14px" font-weight="bold">Full vs. Complete Binary Trees</text>
                    
                    <!-- Full Tree -->
                    <g transform="translate(50, 40)">
                        <text x="60" y="0" text-anchor="middle" fill="#9b59b6" font-size="12px" font-weight="bold">Full Tree</text>
                        <circle cx="60" cy="25" r="12" fill="#9b59b6" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="60" y1="37" x2="30" y2="63" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="60" y1="37" x2="90" y2="63" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="30" cy="75" r="12" fill="#9b59b6" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="90" cy="75" r="12" fill="#9b59b6" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="30" y1="87" x2="15" y2="113" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="30" y1="87" x2="45" y2="113" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="90" y1="87" x2="75" y2="113" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="90" y1="87" x2="105" y2="113" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="15" cy="125" r="12" fill="#9b59b6" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="45" cy="125" r="12" fill="#9b59b6" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="75" cy="125" r="12" fill="#9b59b6" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="105" cy="125" r="12" fill="#9b59b6" stroke="#2c3e50" stroke-width="1.5"/>
                    </g>
                    
                    <!-- Complete Tree -->
                    <g transform="translate(250, 40)">
                        <text x="60" y="0" text-anchor="middle" fill="#16a085" font-size="12px" font-weight="bold">Complete Tree</text>
                        <circle cx="60" cy="25" r="12" fill="#16a085" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="60" y1="37" x2="30" y2="63" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="60" y1="37" x2="90" y2="63" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="30" cy="75" r="12" fill="#16a085" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="90" cy="75" r="12" fill="#16a085" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="30" y1="87" x2="15" y2="113" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="30" y1="87" x2="45" y2="113" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="90" y1="87" x2="75" y2="113" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="15" cy="125" r="12" fill="#16a085" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="45" cy="125" r="12" fill="#16a085" stroke="#2c3e50" stroke-width="1.5"/>
                        <circle cx="75" cy="125" r="12" fill="#16a085" stroke="#2c3e50" stroke-width="1.5"/>
                        <!-- Empty spots for illustration -->
                        <circle cx="105" cy="125" r="12" fill="none" stroke="#95a5a6" stroke-width="1" stroke-dasharray="3,3"/>
                        <circle cx="15" cy="165" r="12" fill="#16a085" stroke="#2c3e50" stroke-width="1.5"/>
                        <line x1="15" y1="137" x2="15" y2="153" stroke="#2c3e50" stroke-width="1.5"/>
                    </g>
                </svg>
                <div class="svg-caption">Figure 7: Visual comparison of a Full tree (every internal node has 2 children) and a Complete tree (filled left-to-right).</div>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Formal Definitions and Comparison</div>
                <p><strong>Full Binary Tree (or Proper Binary Tree):</strong> A binary tree in which every node has either 0 or 2 children. No node has only one child.</p>
                <p><strong>Complete Binary Tree:</strong> A binary tree in which all levels are completely filled except possibly the last level, and all nodes in the last level are as far left as possible.</p>
                <table style="width: 100%; border-collapse: collapse; margin-top: 15px;">
                    <thead>
                        <tr style="background-color: #f2f2f2;">
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Property</th>
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Full Binary Tree</th>
                            <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Complete Binary Tree</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">Children per Node</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Either 0 or 2</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">0, 1, or 2</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">Shape</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Can be unbalanced</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Must be as balanced as possible</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">Node Count</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">If `i` are internal nodes, leaves = `i+1`. Total nodes = `2i+1`.</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Relationship between height and nodes is precise: `2^h <= n <= 2^(h+1)-1`.</td>
                        </tr>
                        <tr>
                            <td style="border: 1px solid #ddd; padding: 8px;">Primary Use</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Expression trees.</td>
                            <td style="border: 1px solid #ddd; padding: 8px;">Efficient array representation (Heaps).</td>
                        </tr>
                    </tbody>
                </table>
                <p><strong>Key Relationship:</strong> A tree can be both Full and Complete (like the "Full Tree" example in Figure 7). A tree can be Complete but not Full (like the "Complete Tree" example, where node 90 has one child). A tree can be Full but not Complete (if the right subtree is much deeper than the left).</p>
            </div>
        </div>
    </div>
    <div class="header">
    </div>
        <div class="header">
        <div class="subtitle">Module 4: Graphs</div>
    </div>
    <div class="section">        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">Explained to a 5-Year-Old:</div>
                <p>Imagine a big map of a city. The <strong>places</strong> you can visit (like your house, the park, the school) are called <strong>vertices</strong>. The <strong>roads</strong> that connect these places are called <strong>edges</strong>. A graph is just a way to draw this map so we can see how all the places are connected to each other!</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Formal Definition & Terminology:</div>
                <p>A <strong>Graph</strong> is an ordered pair G = (V, E) comprising a set V of vertices (also called nodes) and a set E of edges, which are 2-element subsets of V.</p>
                <ul>
                    <li><strong>Vertex (Node):</strong> A fundamental unit of the graph. Represents an entity or object.</li>
                    <li><strong>Edge (Arc):</strong> A link between two vertices. Represents a relationship or connection.</li>
                    <li><strong>Undirected Graph:</strong> Edges have no direction. The edge (A, B) is identical to (B, A). (e.g., a two-way road).</li>
                    <li><strong>Directed Graph (Digraph):</strong> Edges have a direction. The edge (A -> B) is different from (B -> A). (e.g., a one-way street).</li>
                    <li><strong>Weighted Graph:</strong> Each edge has a value (a "weight") associated with it, representing cost, distance, or time.</li>
                    <li><strong>Degree of a Vertex:</strong> The number of edges incident to it. For a directed graph, it has an <strong>in-degree</strong> (incoming edges) and an <strong>out-degree</strong> (outgoing edges).</li>
                    <li><strong>Path:</strong> A sequence of vertices where each adjacent pair is connected by an edge.</li>
                    <li><strong>Cycle:</strong> A path that starts and ends at the same vertex.</li>
                </ul>
            </div>
        </div>

        <div class="concept">
            <h3 class="section-title">Graph Representation: Adjacency Matrix</h3>
            <div class="simple-explanation">
                <div class="simple-title">Explained to a 5-Year-Old:</div>
                <p>Think of a giant bingo card or a spreadsheet. You list all the places down the side and across the top. If there's a direct road between "Park" and "School," you put a "1" in the box where they meet. If there's no road, you put a "0". It's like a checklist of all possible connections.</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Formal Definition & Analysis:</div>
                <p>An <strong>Adjacency Matrix</strong> is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.</p>
                <p>For a graph with V vertices, the matrix is of size V x V. The entry at row `i` and column `j`, `A[i][j]`, is:</p>
                <ul>
                    <li><strong>1</strong> if there is an edge from vertex `i` to vertex `j`.</li>
                    <li><strong>0</strong> otherwise.</li>
                </ul>
                <p>For a weighted graph, the entry is the weight of the edge instead of 1.</p>
                <div class="formula">Space Complexity: O(V¬≤)</div>
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li>Constant time complexity O(1) to check if an edge exists between two vertices.</li>
                    <li>Simple to implement.</li>
                </ul>
                <p><strong>Disadvantages:</strong></p>
                <ul>
                    <li>Consumes a lot of memory (V¬≤ space), even if the graph is sparse (has few edges).</li>
                    <li>Adding/Removing a vertex is expensive as it requires resizing the matrix.</li>
                </ul>
                <div class="svg-container">
                    <svg width="100%" height="300" viewBox="0 0 600 250" xmlns="http://www.w3.org/2000/svg">
                        <!-- Graph -->
                        <g id="graph">
                            <text x="100" y="20" text-anchor="middle" font-family="serif" font-size="16px" font-weight="bold">Graph</text>
                            <!-- Vertices -->
                            <circle cx="50" cy="80" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="85" text-anchor="middle" fill="white" font-family="serif" font-size="14px">0</text>
                            <circle cx="150" cy="80" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="85" text-anchor="middle" fill="white" font-family="serif" font-size="14px">1</text>
                            <circle cx="100" cy="170" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="175" text-anchor="middle" fill="white" font-family="serif" font-size="14px">2</text>
                            <!-- Edges -->
                            <line x1="65" y1="80" x2="135" y2="80" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="58" y1="93" x2="92" y2="157" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="142" y1="93" x2="108" y2="157" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        <!-- Matrix -->
                        <g id="matrix" transform="translate(300, 50)">
                            <text x="100" y="-30" text-anchor="middle" font-family="serif" font-size="16px" font-weight="bold">Adjacency Matrix</text>
                            <!-- Header Row -->
                            <text x="40" y="0" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold"></text>
                            <text x="70" y="0" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold">0</text>
                            <text x="100" y="0" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold">1</text>
                            <text x="130" y="0" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold">2</text>
                            
                            <!-- Row 0 -->
                            <text x="40" y="30" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold">0</text>
                            <rect x="55" y="15" width="30" height="30" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="70" y="35" text-anchor="middle" font-family="serif" font-size="14px">0</text>
                            <rect x="85" y="15" width="30" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="100" y="35" text-anchor="middle" font-family="serif" font-size="14px">1</text>
                            <rect x="115" y="15" width="30" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="130" y="35" text-anchor="middle" font-family="serif" font-size="14px">1</text>
                            
                            <!-- Row 1 -->
                            <text x="40" y="60" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold">1</text>
                            <rect x="55" y="45" width="30" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="70" y="65" text-anchor="middle" font-family="serif" font-size="14px">1</text>
                            <rect x="85" y="45" width="30" height="30" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="100" y="65" text-anchor="middle" font-family="serif" font-size="14px">0</text>
                            <rect x="115" y="45" width="30" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="130" y="65" text-anchor="middle" font-family="serif" font-size="14px">1</text>
                            
                            <!-- Row 2 -->
                            <text x="40" y="90" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold">2</text>
                            <rect x="55" y="75" width="30" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="70" y="95" text-anchor="middle" font-family="serif" font-size="14px">1</text>
                            <rect x="85" y="75" width="30" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="100" y="95" text-anchor="middle" font-family="serif" font-size="14px">1</text>
                            <rect x="115" y="75" width="30" height="30" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="130" y="95" text-anchor="middle" font-family="serif" font-size="14px">0</text>
                        </g>
                    </svg>
                    <p class="svg-caption">Figure 1: An undirected graph and its corresponding adjacency matrix. The highlighted cells (e.g., A[0][1]=1) correspond to the edges in the graph.</p>
                </div>
            </div>
        </div>

        <div class="concept">
            <h3 class="section-title">Graph Representation: Adjacency List</h3>
            <div class="simple-explanation">
                <div class="simple-title">Explained to a 5-Year-Old:</div>
                <p>Imagine you have a contact list on your phone. For each person (a vertex), you keep a list of all their friends (the vertices they are connected to). So, for "Mom," you have a list that includes "Grandma" and "Dad." This is much smaller than the giant bingo card if most people only have a few friends!</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Formal Definition & Analysis:</div>
                <p>An <strong>Adjacency List</strong> represents a graph as an array of linked lists. The index of the array represents a vertex, and each element in its linked list represents a vertex that forms an edge with the array vertex.</p>
                <div class="formula">Space Complexity: O(V + E)</div>
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li>Memory efficient for sparse graphs, as it only stores existing edges.</li>
                    <li>Adding/Removing a vertex or edge is relatively easy.</li>
                </ul>
                <p><strong>Disadvantages:</strong></p>
                <ul>
                    <li>Checking if an edge exists between two vertices can be slow, O(V) in the worst case, as it may require traversing a linked list.</li>
                </ul>
                <div class="svg-container">
                    <svg width="100%" height="300" viewBox="0 0 600 250" xmlns="http://www.w3.org/2000/svg">
                        <!-- Graph -->
                        <g id="graph-list">
                            <text x="100" y="20" text-anchor="middle" font-family="serif" font-size="16px" font-weight="bold">Graph</text>
                            <!-- Vertices -->
                            <circle cx="50" cy="80" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="85" text-anchor="middle" fill="white" font-family="serif" font-size="14px">0</text>
                            <circle cx="150" cy="80" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="85" text-anchor="middle" fill="white" font-family="serif" font-size="14px">1</text>
                            <circle cx="100" cy="170" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="175" text-anchor="middle" fill="white" font-family="serif" font-size="14px">2</text>
                            <!-- Edges -->
                            <line x1="65" y1="80" x2="135" y2="80" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="58" y1="93" x2="92" y2="157" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="142" y1="93" x2="108" y2="157" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        <!-- List -->
                        <g id="adj-list" transform="translate(300, 40)">
                            <text x="100" y="-20" text-anchor="middle" font-family="serif" font-size="16px" font-weight="bold">Adjacency List</text>
                            
                            <!-- List for 0 -->
                            <rect x="50" y="0" width="30" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="65" y="17" text-anchor="middle" fill="white" font-family="serif" font-size="14px">0</text>
                            <line x1="80" y1="12" x2="90" y2="12" stroke="#2c3e50" stroke-width="2"/>
                            <rect x="90" y="0" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="105" y="17" text-anchor="middle" font-family="serif" font-size="14px">1</text>
                            <line x1="120" y1="12" x2="130" y2="12" stroke="#2c3e50" stroke-width="2"/>
                            <rect x="130" y="0" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="145" y="17" text-anchor="middle" font-family="serif" font-size="14px">2</text>
                            <line x1="160" y1="12" x2="170" y2="12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="175" y="17" text-anchor="middle" font-family="serif" font-size="14px">NULL</text>

                            <!-- List for 1 -->
                            <rect x="50" y="50" width="30" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="65" y="67" text-anchor="middle" fill="white" font-family="serif" font-size="14px">1</text>
                            <line x1="80" y1="62" x2="90" y2="62" stroke="#2c3e50" stroke-width="2"/>
                            <rect x="90" y="50" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="105" y="67" text-anchor="middle" font-family="serif" font-size="14px">0</text>
                            <line x1="120" y1="62" x2="130" y2="62" stroke="#2c3e50" stroke-width="2"/>
                            <rect x="130" y="50" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="145" y="67" text-anchor="middle" font-family="serif" font-size="14px">2</text>
                            <line x1="160" y1="62" x2="170" y2="62" stroke="#2c3e50" stroke-width="2"/>
                            <text x="175" y="67" text-anchor="middle" font-family="serif" font-size="14px">NULL</text>

                            <!-- List for 2 -->
                            <rect x="50" y="100" width="30" height="25" fill="#3498db" stroke="#2c3e50" stroke-width="1"/>
                            <text x="65" y="117" text-anchor="middle" fill="white" font-family="serif" font-size="14px">2</text>
                            <line x1="80" y1="112" x2="90" y2="112" stroke="#2c3e50" stroke-width="2"/>
                            <rect x="90" y="100" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="105" y="117" text-anchor="middle" font-family="serif" font-size="14px">0</text>
                            <line x1="120" y1="112" x2="130" y2="112" stroke="#2c3e50" stroke-width="2"/>
                            <rect x="130" y="100" width="30" height="25" fill="#f8f9fa" stroke="#2c3e50" stroke-width="1"/>
                            <text x="145" y="117" text-anchor="middle" font-family="serif" font-size="14px">1</text>
                            <line x1="160" y1="112" x2="170" y2="112" stroke="#2c3e50" stroke-width="2"/>
                            <text x="175" y="117" text-anchor="middle" font-family="serif" font-size="14px">NULL</text>
                        </g>
                    </svg>
                    <p class="svg-caption">Figure 2: An undirected graph and its corresponding adjacency list. The array index corresponds to the vertex, and the linked list contains its adjacent vertices.</p>
                </div>
            </div>
        </div>

        <div class="concept">
            <h3 class="section-title">Graph Traversal: Breadth-First Search (BFS)</h3>
            <div class="simple-explanation">
                <div class="simple-title">Explained to a 5-Year-Old:</div>
                <p>Imagine you're dropping a pebble in a pond. The ripples spread out in circles. BFS explores a graph like that. It starts at one place, then visits all its immediate neighbors (the first ripple), then visits all of *their* neighbors (the second ripple), and so on, layer by layer. It's great for finding the shortest path in a map where all roads are equal length.</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Algorithm & Analysis:</div>
                <p>BFS is a graph traversal algorithm that explores vertices in layers. It starts at a given source vertex and explores all of its immediate neighbors. Then, for each of those neighbors, it explores their unvisited neighbors. It uses a <strong>Queue</strong> data structure to keep track of the vertices to visit next.</p>
                <p><strong>Algorithm Steps:</strong></p>
                <ol>
                    <li>Mark the starting vertex as visited and enqueue it.</li>
                    <li>Loop as long as the queue is not empty:
                        <ol>
                            <li>Dequeue a vertex `u`.</li>
                            <li>For each neighbor `v` of `u`:
                                <ol>
                                    <li>If `v` has not been visited, mark it as visited and enqueue `v`.</li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                </ol>
                <div class="formula">Time Complexity: O(V + E)</div>
                <p><strong>Applications:</strong></p>
                <ul>
                    <li>Finding the shortest path in an unweighted graph.</li>
                    <li>Finding all connected components in a graph.</li>
                    <li>Web crawlers use BFS to build indexes.</li>
                </ul>
                <div class="svg-container">
                    <svg width="100%" height="400" viewBox="0 0 600 450" xmlns="http://www.w3.org/2000/svg">
                        <text x="300" y="20" text-anchor="middle" font-family="serif" font-size="16px" font-weight="bold">BFS Traversal starting from Vertex A</text>
                        
                        <!-- Graph -->
                        <g id="bfs-graph" transform="translate(200, 50)">
                            <!-- Vertices -->
                            <circle id="vA" cx="100" cy="50" r="20" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="55" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">A</text>
                            
                            <circle id="vB" cx="30" cy="130" r="20" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="30" y="135" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">B</text>
                            
                            <circle id="vC" cx="170" cy="130" r="20" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="170" y="135" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">C</text>

                            <circle id="vD" cx="30" cy="230" r="20" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="30" y="235" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">D</text>

                            <circle id="vE" cx="100" cy="230" r="20" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="235" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">E</text>

                            <circle id="vF" cx="170" cy="230" r="20" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="170" y="235" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">F</text>

                            <!-- Edges -->
                            <line x1="85" y1="65" x2="45" y2="115" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="115" y1="65" x2="155" y2="115" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="30" y1="150" x2="30" y2="210" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="45" y1="145" x2="85" y2="215" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="155" y1="145" x2="115" y2="215" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="170" y1="150" x2="170" y2="210" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        
                        <!-- Queue visualization -->
                        <g id="queue" transform="translate(50, 320)">
                            <text x="250" y="0" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold">Queue State</text>
                            <rect x="150" y="10" width="40" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="170" y="30" text-anchor="middle" fill="white" font-family="serif" font-size="14px">A</text>
                            <text x="130" y="30" text-anchor="middle" font-family="serif" font-size="14px" font-style="italic">Front</text>
                            <text x="210" y="30" text-anchor="middle" font-family="serif" font-size="14px" font-style="italic">Rear</text>
                        </g>

                        <text x="300" y="400" text-anchor="middle" font-family="serif" font-size="14px">Traversal Order: A -> B -> C -> D -> E -> F</text>
                    </svg>
                    <p class="svg-caption">Figure 3: BFS traversal starting from vertex A. Colors indicate the layer in which the vertex is visited (Red: Layer 0, Orange: Layer 1, Green: Layer 2).</p>
                </div>
            </div>
        </div>

        <div class="concept">
            <h3 class="section-title">Graph Traversal: Depth-First Search (DFS)</h3>
            <div class="simple-explanation">
                <div class="simple-title">Explained to a 5-Year-Old:</div>
                <p>Imagine you're exploring a maze. You pick one path and follow it as far as you can go until you hit a dead end. When you do, you turn around and go back to the last place where you had a choice, and try a different path. DFS explores a graph just like that: it goes deep down one branch before coming back to explore others.</p>
            </div>
            <div class="deep-explanation">
                <div class="deep-title">Algorithm & Analysis:</div>
                <p>DFS is a graph traversal algorithm that explores as far as possible along each branch before backtracking. It can be implemented using a <strong>Stack</strong> (iterative version) or through <strong>recursion</strong> (where the call stack acts as the stack).</p>
                <p><strong>Algorithm Steps (Recursive):</strong></p>
                <ol>
                    <li>Mark the current vertex `u` as visited.</li>
                    <li>For each neighbor `v` of `u`:
                        <ol>
                            <li>If `v` has not been visited, recursively call DFS on `v`.</li>
                        </ol>
                    </li>
                </ol>
                <div class="formula">Time Complexity: O(V + E)</div>
                <p><strong>Applications:</strong></p>
                <ul>
                    <li>Detecting cycles in a graph.</li>
                    <li>Topological sorting.</li>
                    <li>Finding strongly connected components.</li>
                    <li>Solving puzzles with only one solution (like mazes).</li>
                </ul>
                <div class="svg-container">
                    <svg width="100%" height="400" viewBox="0 0 600 450" xmlns="http://www.w3.org/2000/svg">
                        <text x="300" y="20" text-anchor="middle" font-family="serif" font-size="16px" font-weight="bold">DFS Traversal starting from Vertex A</text>
                        
                        <!-- Graph -->
                        <g id="dfs-graph" transform="translate(200, 50)">
                            <!-- Path line -->
                            <path d="M 100 70 L 30 150 L 30 210 L 100 210 L 170 150 L 170 210" fill="none" stroke="#e74c3c" stroke-width="4" stroke-dasharray="5,5" opacity="0.7"/>

                            <!-- Vertices -->
                            <circle id="vA-d" cx="100" cy="50" r="20" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="55" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">A</text>
                            
                            <circle id="vB-d" cx="30" cy="130" r="20" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="30" y="135" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">B</text>
                            
                            <circle id="vC-d" cx="170" cy="130" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="170" y="135" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">C</text>

                            <circle id="vD-d" cx="30" cy="230" r="20" fill="#9b59b6" stroke="#2c3e50" stroke-width="2"/>
                            <text x="30" y="235" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">D</text>

                            <circle id="vE-d" cx="100" cy="230" r="20" fill="#1abc9c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="235" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">E</text>

                            <circle id="vF-d" cx="170" cy="230" r="20" fill="#2ecc71" stroke="#2c3e50" stroke-width="2"/>
                            <text x="170" y="235" text-anchor="middle" fill="white" font-family="serif" font-size="16px" font-weight="bold">F</text>

                            <!-- Edges -->
                            <line x1="85" y1="65" x2="45" y2="115" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="115" y1="65" x2="155" y2="115" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="30" y1="150" x2="30" y2="210" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="45" y1="145" x2="85" y2="215" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="155" y1="145" x2="115" y2="215" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="170" y1="150" x2="170" y2="210" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        
                        <!-- Stack visualization -->
                        <g id="stack" transform="translate(50, 320)">
                            <text x="250" y="0" text-anchor="middle" font-family="serif" font-size="14px" font-weight="bold">Call Stack (Conceptual)</text>
                            <rect x="150" y="10" width="40" height="30" fill="#f39c12" stroke="#2c3e50" stroke-width="1"/>
                            <text x="170" y="30" text-anchor="middle" fill="white" font-family="serif" font-size="14px">B</text>
                            <rect x="150" y="40" width="40" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="1"/>
                            <text x="170" y="60" text-anchor="middle" fill="white" font-family="serif" font-size="14px">A</text>
                            <text x="210" y="30" text-anchor="middle" font-family="serif" font-size="14px" font-style="italic">Top</text>
                        </g>

                        <text x="300" y="400" text-anchor="middle" font-family="serif" font-size="14px">One possible Traversal Order: A -> B -> D -> E -> C -> F</text>
                    </svg>
                    <p class="svg-caption">Figure 4: DFS traversal starting from vertex A. The dashed line shows the deep path taken. Colors indicate the order of visitation. The call stack shows the state during the exploration of vertex B.</p>
                </div>
            </div>
        </div>
    </div>

    <header class="header">
        <h2 class="subtitle">Module 5: Sorting and Searching</h2>
    </header>

    <main>
        <section class="section">
            <h2 class="section-title">1. Introduction to Sorting</h2>
            <div class="concept">
                <div class="simple-explanation">
                    <p class="simple-title">Explained for a 5-Year-Old:</p>
                    <p>Imagine you have a big box of colorful toy cars all mixed up. Sorting is like putting all the red cars in one pile, all the blue cars in another, and so on, until everything is neat and easy to find. We do this with numbers on a computer, too, to arrange them from smallest to biggest (or biggest to smallest).</p>
                </div>
                <div class="deep-explanation">
                    <p class="deep-title">Formal Definition & Importance:</p>
                    <p>Sorting is the algorithmic process of arranging elements in a sequence (e.g., numerical order, lexicographical order) according to a total order. The efficiency of a sorting algorithm is critical, as it forms the basis for many other complex algorithms (like searching) and for optimizing data storage. A sorted array allows for drastically faster searching (e.g., Binary Search) compared to an unsorted one (Linear Search). The primary metrics for evaluating sorting algorithms are <strong>Time Complexity</strong> (how the runtime scales with input size `n`) and <strong>Space Complexity</strong> (how much extra memory is required).</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2 class="section-title">2. Internal Sorting Algorithms</h2>
            
            <div class="concept">
                <h3>2.1 Insertion Sort</h3>
                <div class="simple-explanation">
                    <p class="simple-title">Explained for a 5-Year-Old:</p>
                    <p>Think about how you sort a hand of playing cards. You pick up one card at a time from the messy pile and slide it into its correct spot among the cards you're already holding, which are already sorted. You keep doing this until all the cards from the pile are in your hand, in perfect order.</p>
                </div>
                <div class="deep-explanation">
                    <p class="deep-title">Algorithm & Analysis:</p>
                    <p>Insertion Sort is a simple, in-place comparison-based sorting algorithm. It builds the final sorted array one item at a time. It iterates through the input elements and, for each element, finds its correct position in the sorted part of the array and inserts it there.</p>
                    <div class="code">Algorithm InsertionSort(A[0...n-1])
    for i = 1 to n-1
        key = A[i]
        j = i - 1
        // Move elements of A[0..i-1] that are greater than key
        // to one position ahead of their current position
        while j >= 0 and A[j] > key
            A[j+1] = A[j]
            j = j - 1
        end while
        A[j+1] = key
    end for
end Algorithm</div>
                    <p><strong>Time Complexity:</strong> Best Case: O(n) - when the array is already sorted. Worst Case: O(n¬≤) - when the array is sorted in reverse. Average Case: O(n¬≤). <strong>Space Complexity:</strong> O(1) - it sorts in-place. <strong>Stability:</strong> Yes, it is a stable sort as it does not change the relative order of elements with equal keys. It is efficient for small datasets and nearly sorted data.</p>
                </div>
                <div class="svg-container">
                    <svg width="600" height="80" viewBox="0 0 600 80">
                        <text x="10" y="25" font-family="Arial" font-size="14" fill="#333">Pass 1: Insert 2</text>
                        <rect x="100" y="40" width="40" height="30" fill="#3498db" stroke="#2c3e50"/>
                        <text x="115" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">5</text>
                        <rect x="140" y="40" width="40" height="30" fill="#e74c3c" stroke="#2c3e50"/>
                        <text x="155" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">2</text>
                        <rect x="180" y="40" width="40" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="195" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">4</text>
                        <rect x="220" y="40" width="40" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="235" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">6</text>
                        <rect x="260" y="40" width="40" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="275" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">1</text>
                        <rect x="300" y="40" width="40" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="315" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">3</text>
                        <path d="M 155 35 L 115 35" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>
                    </svg>
                    <p class="svg-caption">Figure 1: First pass of Insertion Sort on [5, 2, 4, 6, 1, 3]. The element 2 is inserted into the sorted subarray [5].</p>
                </div>
                <div class="example">
                    <p class="example-title">Exam Walkthrough:</p>
                    <p>Sort the list: <code>[12, 65, 34, 9, 56, 43, 10]</code> (from 2022 Q19a). Initial: [12, 65, 34, 9, 56, 43, 10].<br>
                    Pass 1 (key=65): [12, 65, 34, 9, 56, 43, 10] (no change).<br>
                    Pass 2 (key=34): [12, 34, 65, 9, 56, 43, 10].<br>
                    Pass 3 (key=9): [9, 12, 34, 65, 56, 43, 10].<br>
                    ...and so on, until the final sorted array: <code>[9, 10, 12, 34, 43, 56, 65]</code>.</p>
                </div>
            </div>

            <div class="concept">
                <h3>2.2 Merge Sort</h3>
                <div class="simple-explanation">
                    <p class="simple-title">Explained for a 5-Year-Old:</p>
                    <p>Imagine you have a huge pile of unsorted blocks. You split the pile into two smaller piles. Then you split those piles again, and again, until every pile has only one block (which is already sorted!). Then you start merging them back together: you take two single-block piles, sort them to make a two-block pile. Then you take two two-block piles and merge them into a perfect four-block pile, and so on, until you have one big, perfectly sorted pile again.</p>
                </div>
                <div class="deep-explanation">
                    <p class="deep-title">Algorithm & Analysis:</p>
                    <p>Merge Sort is a classic <strong>Divide and Conquer</strong> algorithm. It divides the unsorted list into n sublists, each containing one element (which are considered sorted). Then it repeatedly merges sublists to produce new sorted sublists until there is only one sublist remaining, which is the sorted list.</p>
                    <div class="code">Algorithm MergeSort(A, p, r)
    if p < r
        q = floor((p+r)/2)
        MergeSort(A, p, q)
        MergeSort(A, q+1, r)
        Merge(A, p, q, r)
    end if
end Algorithm</div>
                    <p><strong>Time Complexity:</strong> Best, Average, and Worst Case are all O(n log n). This is because the list is divided log n times, and each level of division requires a linear O(n) merge operation. <strong>Space Complexity:</strong> O(n) - it requires an auxiliary array of the same size as the input for the merging process. <strong>Stability:</strong> Yes, it is a stable sort. Its consistent O(n log n) performance makes it highly reliable for large datasets.</p>
                </div>
                <div class="svg-container">
                    <svg width="650" height="250" viewBox="0 0 650 250">
                        <text x="10" y="25" font-family="Arial" font-size="14" fill="#333">Divide Phase</text>
                        <line x1="50" y1="40" x2="600" y2="40" stroke="#333" stroke-width="1"/>
                        <text x="250" y="60" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">[38, 27, 43, 3, 9, 82, 10]</text>
                        <line x1="200" y1="40" x2="200" y2="70" stroke="#333" stroke-width="1"/>
                        <line x1="400" y1="40" x2="400" y2="70" stroke="#333" stroke-width="1"/>
                        <text x="150" y="90" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">[38, 27, 43]</text>
                        <text x="450" y="90" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">[3, 9, 82, 10]</text>
                        <line x1="125" y1="70" x2="125" y2="100" stroke="#333" stroke-width="1"/>
                        <line x1="225" y1="70" x2="225" y2="100" stroke="#333" stroke-width="1"/>
                        <text x="100" y="120" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">[38, 27]</text>
                        <text x="200" y="120" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">[43]</text>
                        <text x="75" y="150" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">[38]</text>
                        <text x="125" y="150" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">[27]</text>
                        
                        <text x="10" y="180" font-family="Arial" font-size="14" fill="#333">Conquer (Merge) Phase</text>
                        <line x1="50" y1="195" x2="600" y2="195" stroke="#333" stroke-width="1"/>
                        <text x="100" y="215" font-family="Arial" font-size="12" fill="#e74c3c" text-anchor="middle">[27, 38]</text>
                        <text x="200" y="215" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">[43]</text>
                        <text x="150" y="235" font-family="Arial" font-size="12" fill="#e74c3c" text-anchor="middle">[27, 38, 43]</text>
                        <text x="450" y="235" font-family="Arial" font-size="12" fill="#e74c3c" text-anchor="middle">[3, 9, 10, 82]</text>
                        <text x="300" y="250" font-family="Arial" font-size="12" fill="#e74c3c" text-anchor="middle" font-weight="bold">[3, 9, 10, 27, 38, 43, 82]</text>
                    </svg>
                    <p class="svg-caption">Figure 2: Merge Sort's Divide and Conquer process on an example array.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2 class="section-title">3. Searching Algorithms</h2>
            <div class="concept">
                <h3>3.1 Binary Search</h3>
                <div class="simple-explanation">
                    <p class="simple-title">Explained for a 5-Year-Old:</p>
                    <p>Imagine you're looking for a specific page in a very thick book. You wouldn't start from page 1 and flip through every single page. Instead, you'd open the book right in the middle. Is the page number you need higher or lower than the page you're on? If it's lower, you'll only look in the first half of the book. You keep cutting the search area in half like this until you find the exact page. It's super fast!</p>
                </div>
                <div class="deep-explanation">
                    <p class="deep-title">Algorithm & Analysis:</p>
                    <p>Binary Search is a highly efficient searching algorithm that works on the principle of <strong>divide and conquer</strong>. It requires the array to be <strong>sorted</strong> beforehand. The algorithm compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated, and the search continues on the remaining half. This process is repeated until the value is found or the interval is empty.</p>
                    <div class="code">Algorithm BinarySearch(A[0...n-1], key)
    low = 0
    high = n-1
    while low <= high
        mid = floor((low + high) / 2)
        if A[mid] == key
            return mid // Element found
        else if A[mid] < key
            low = mid + 1
        else
            high = mid - 1
        end if
    end while
    return -1 // Element not found
end Algorithm</div>
                    <p><strong>Time Complexity:</strong> Best Case: O(1) - when the middle element is the target. Worst and Average Case: O(log n) - because the search space is halved in each iteration. <strong>Space Complexity:</strong> O(1) for the iterative version. O(log n) for the recursive version due to the call stack. Its efficiency makes it indispensable for searching in large, static datasets.</p>
                </div>
                <div class="svg-container">
                    <svg width="600" height="120" viewBox="0 0 600 120">
                        <text x="10" y="20" font-family="Arial" font-size="14" fill="#333">Search for key = 23 in [3, 8, 12, 15, 23, 31, 42]</text>
                        <rect x="50" y="40" width="50" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="75" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">3</text>
                        <rect x="100" y="40" width="50" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="125" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">8</text>
                        <rect x="150" y="40" width="50" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="175" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">12</text>
                        <rect x="200" y="40" width="50" height="30" fill="#3498db" stroke="#2c3e50"/>
                        <text x="225" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">15</text>
                        <rect x="250" y="40" width="50" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="275" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">23</text>
                        <rect x="300" y="40" width="50" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="325" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">31</text>
                        <rect x="350" y="40" width="50" height="30" fill="#95a5a6" stroke="#2c3e50"/>
                        <text x="375" y="60" font-family="Arial" font-size="14" fill="white" text-anchor="middle">42</text>
                        <text x="225" y="90" font-family="Arial" font-size="12" fill="#3498db" text-anchor="middle">mid=3, A[mid]=15</text>
                        <text x="225" y="105" font-family="Arial" font-size="12" fill="#333" text-anchor="middle">15 < 23, search right</text>
                    </svg>
                    <p class="svg-caption">Figure 3: First step of Binary Search. The middle element (15) is less than the key (23), so the search continues in the right half of the array.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2 class="section-title">4. Hashing</h2>
            <div class="concept">
                <h3>4.1 Concept & Hash Functions</h3>
                <div class="simple-explanation">
                    <p class="simple-title">Explained for a 5-Year-Old:</p>
                    <p>Imagine a giant coat check room with a hundred hooks, numbered 0 to 99. The "hash function" is a magic rule. If you give the attendant your coat (your "data"), they look at the name tag (your "key") and use the rule to instantly know which exact hook to put it on. For example, the rule might be "add up the letters in the name and find the remainder when you divide by 100". This makes finding your coat super fast later!</p>
                </div>
                <div class="deep-explanation">
                    <p class="deep-title">Formal Definition:</p>
                    <p>Hashing is a technique used to uniquely identify a specific object from a group of similar objects. It uses a <strong>hash function</strong> `h(k)` to compute an index into an array of buckets or slots, from which the desired value can be found. The primary goal is to map keys to array indices in a way that allows for O(1) average-case time complexity for search, insert, and delete operations.</p>
                    <p><strong>Collision:</strong> Since the number of possible keys is typically much larger than the number of array slots, a <strong>collision</strong> occurs when the hash function maps two different keys to the same index. A good hash function minimizes collisions, but a robust system must have a <strong>collision resolution technique</strong> to handle them.</p>
                    <p><strong>Common Hash Functions:</strong></p>
                    <ul>
                        <li><strong>Division Method:</strong> <code class="formula">h(k) = k mod m</code>, where `m` is the table size. `m` should be a prime number to reduce collisions.</li>
                        <li><strong>Mid-Square Method:</strong> Square the key `k`, then extract the middle `r` digits as the hash value. Useful when key sizes vary.</li>
                        <li><strong>Folding Method:</strong> Divide the key `k` into equal-sized parts (except possibly the last), then sum the parts to get the hash value.</li>
                    </ul>
                </div>
                <div class="svg-container">
                    <svg width="500" height="100" viewBox="0 0 500 100">
                        <text x="10" y="20" font-family="Arial" font-size="14" fill="#333">Hash Function Process</text>
                        <rect x="20" y="40" width="80" height="40" fill="#ecf0f1" stroke="#2c3e50" stroke-dasharray="5,5"/>
                        <text x="60" y="65" font-family="Arial" font-size="14" fill="#333" text-anchor="middle">Key (k)</text>
                        <rect x="200" y="40" width="120" height="40" fill="#3498db" stroke="#2c3e50"/>
                        <text x="260" y="65" font-family="Arial" font-size="14" fill="white" text-anchor="middle">Hash Function h(k)</text>
                        <rect x="380" y="40" width="80" height="40" fill="#e74c3c" stroke="#2c3e50"/>
                        <text x="420" y="65" font-family="Arial" font-size="14" fill="white" text-anchor="middle">Index</text>
                        <path d="M 100 60 L 200 60" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead2)"/>
                        <path d="M 320 60 L 380 60" stroke="#333" stroke-width="2" fill="none" marker-end="url(#arrowhead2)"/>
                        <defs>
                            <marker id="arrowhead2" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#333"/>
                            </marker>
                        </defs>
                    </svg>
                    <p class="svg-caption">Figure 4: The process of hashing a key to obtain an array index.</p>
                </div>
            </div>

            <div class="concept">
                <h3>4.2 Collision Resolution Techniques</h3>
                <div class="simple-explanation">
                    <p class="simple-title">Explained for a 5-Year-Old:</p>
                    <p>Sometimes, the magic rule tells the attendant to put two different coats on the same hook! That's a "collision". How do they solve it?</p>
                    <p><strong>Open Chaining:</strong> The attendant just hangs a second hook from the first one and puts the new coat there. A chain of coats!</p>
                    <p><strong>Linear Probing:</strong> The attendant sees the hook is full, so they try the very next hook. If that's full, they try the next one, and so on, until they find an empty hook.</p>
                </div>
                <div class="deep-explanation">
                    <p class="deep-title">Techniques & Analysis:</p>
                    <p><strong>1. Open Addressing (Closed Hashing):</strong> All elements are stored within the hash table itself. When a collision occurs, the algorithm probes for the next available slot according to a specific rule.</p>
                    <ul>
                        <li><strong>Linear Probing:</strong> If slot `h(k)` is occupied, try `h(k) + 1`, then `h(k) + 2`, and so on, wrapping around to the beginning of the table if necessary. Simple but suffers from <strong>primary clustering</strong>, where collided keys form long contiguous blocks.</li>
                        <li><strong>Double Hashing:</strong> Uses a second hash function `h2(k)` to determine the probe sequence. The i-th probe is at `(h(k) + i * h2(k)) mod m`. This helps to avoid clustering as the step size varies for different keys. `h2(k)` must be chosen carefully (e.g., `h2(k) = R - (k mod R)` where `R` is a prime smaller than `m`).</li>
                    </ul>
                    <p><strong>2. Chaining (Open Hashing):</strong> The hash table is an array of pointers, each pointing to the head of a linked list. All keys that hash to the same index `i` are stored in the linked list at `A[i]`. Insertion involves appending to the list. Searching involves computing the hash and then traversing the list. Deletion is straightforward in a linked list. This method avoids clustering entirely, but requires extra memory for the pointers.</p>
                </div>
                <div class="svg-container">
                    <svg width="600" height="180" viewBox="0 0 600 180">
                        <text x="10" y="20" font-family="Arial" font-size="14" fill="#333">Collision Resolution: Chaining vs Linear Probing</text>
                        <text x="10" y="45" font-family="Arial" font-size="12" fill="#333" font-weight="bold">Chaining (h(k)=k mod 7)</text>
                        <rect x="50" y="50" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="70" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">0</text>
                        <rect x="90" y="50" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="110" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">1</text>
                        <rect x="130" y="50" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="150" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">2</text>
                        <rect x="170" y="50" width="40" height="25" fill="#e74c3c" stroke="#2c3e50"/>
                        <text x="190" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">3</text>
                        <rect x="210" y="50" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="230" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">4</text>
                        <rect x="250" y="50" width="40" height="25" fill="#e74c3c" stroke="#2c3e50"/>
                        <text x="270" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">5</text>
                        <rect x="290" y="50" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="310" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">6</text>
                        
                        <line x1="190" y1="75" x2="190" y2="90" stroke="#333" stroke-width="1"/>
                        <circle cx="190" cy="95" r="8" fill="#3498db" stroke="#2c3e50"/>
                        <text x="190" y="99" font-family="Arial" font-size="8" fill="white" text-anchor="middle">23</text>
                        <line x1="198" y1="95" x2="208" y2="95" stroke="#333" stroke-width="1"/>
                        <circle cx="215" cy="95" r="8" fill="#3498db" stroke="#2c3e50"/>
                        <text x="215" y="99" font-family="Arial" font-size="8" fill="white" text-anchor="middle">30</text>

                        <line x1="270" y1="75" x2="270" y2="90" stroke="#333" stroke-width="1"/>
                        <circle cx="270" cy="95" r="8" fill="#3498db" stroke="#2c3e50"/>
                        <text x="270" y="99" font-family="Arial" font-size="8" fill="white" text-anchor="middle">26</text>

                        <text x="350" y="45" font-family="Arial" font-size="12" fill="#333" font-weight="bold">Linear Probing (h(k)=k mod 7)</text>
                        <rect x="390" y="50" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="410" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">0</text>
                        <rect x="430" y="50" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="450" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">1</text>
                        <rect x="470" y="50" width="40" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="490" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">2</text>
                        <rect x="510" y="50" width="40" height="25" fill="#e74c3c" stroke="#2c3e50"/>
                        <text x="530" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">3</text>
                        <rect x="550" y="50" width="40" height="25" fill="#e74c3c" stroke="#2c3e50"/>
                        <text x="570" y="67" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">4</text>
                        
                        <text x="530" y="85" font-family="Arial" font-size="8" fill="white" text-anchor="middle">23</text>
                        <text x="570" y="85" font-family="Arial" font-size="8" fill="white" text-anchor="middle">30</text>
                        <text x="530" y="95" font-family="Arial" font-size="8" fill="#333" text-anchor="middle">(h=3)</text>
                        <text x="570" y="95" font-family="Arial" font-size="8" fill="#333" text-anchor="middle">(h=2, coll. -> 4)</text>
                    </svg>
                    <p class="svg-caption">Figure 5: Comparing Chaining and Linear Probing for inserting keys 23 and 30 (h(23)=3, h(30)=2) into a table of size 7.</p>
                </div>
                <div class="example">
                    <p class="example-title">Exam Walkthrough (from 2022 Q20b & 2023 Q20a):</p>
                    <p><strong>Keys:</strong> {16, 21, 23, 50, 19, 26}. <strong>Table Size:</strong> 7. <strong>Hash Function:</strong> H(K) = K mod 7.</p>
                    <p><strong>Open Chaining:</strong>
                    <br>H(16)=2, H(21)=0, H(23)=2, H(50)=1, H(19)=5, H(26)=5.
                    <br>Slot 0: [21] -> Slot 1: [50] -> Slot 2: [16] -> [23] -> Slot 5: [19] -> [26].</p>
                    <p><strong>Linear Probing:</strong>
                    <br>H(16)=2 -> Insert at 2. [ , ,16, , , , ]
                    <br>H(21)=0 -> Insert at 0. [21, ,16, , , , ]
                    <br>H(23)=2 -> Collides at 2, try 3. Insert at 3. [21, ,16,23, , , ]
                    <br>H(50)=1 -> Insert at 1. [21,50,16,23, , , ]
                    <br>H(19)=5 -> Insert at 5. [21,50,16,23, ,19, ]
                    <br>H(26)=5 -> Collides at 5, try 6. Insert at 6. [21,50,16,23, ,19,26]</p>
                </div>
            </div>
        </section>
        
        <section class="section">
            <h2 class="section-title">5. Heaps</h2>
            <div class="concept">
                <h3>5.1 Max Heap & Min Heap</h3>
                <div class="simple-explanation">
                    <p class="simple-title">Explained for a 5-Year-Old:</p>
                    <p>A <strong>Max-Heap</strong> is like a family tree where every parent is older (has a bigger number) than all their children. The oldest grandparent of all is at the very top of the tree. A <strong>Min-Heap</strong> is the opposite: every parent is younger (has a smaller number) than all their children, and the youngest baby is at the top.</p>
                </div>
                <div class="deep-explanation">
                    <p class="deep-title">Formal Definition & Properties:</p>
                    <p>A Heap is a specialized tree-based data structure that satisfies the <strong>heap property</strong>. It is also a <strong>complete binary tree</strong>, meaning all levels are fully filled except possibly the last, which is filled from left to right.</p>
                    <p><strong>Max-Heap Property:</strong> For any given node `i`, the value of `i` is greater than or equal to the value of its children. `A[parent(i)] >= A[i]`. The largest element is always at the root (index 0).</p>
                    <p><strong>Min-Heap Property:</strong> For any given node `i`, the value of `i` is less than or equal to the value of its children. `A[parent(i)] <= A[i]`. The smallest element is always at the root.</p>
                    <p><strong>Array Representation:</strong> A complete binary tree can be efficiently stored in an array. For an element at index `i`:
                    <div class="formula">Parent(i) = floor((i-1)/2)  |  Left Child(i) = 2*i + 1  |  Right Child(i) = 2*i + 2</div>
                    This representation avoids pointer overhead and is crucial for Heap Sort.</p>
                    <p><strong>Application:</strong> Heaps are the basis for <strong>Priority Queues</strong> (where the highest/lowest priority item is always needed next) and the <strong>Heap Sort</strong> algorithm.</p>
                </div>
                <div class="svg-container">
                    <svg width="600" height="200" viewBox="0 0 600 200">
                        <text x="10" y="20" font-family="Arial" font-size="14" fill="#333">Max-Heap Example</text>
                        <circle cx="300" cy="50" r="20" fill="#e74c3c" stroke="#2c3e50"/>
                        <text x="300" y="55" font-family="Arial" font-size="14" fill="white" text-anchor="middle">90</text>
                        <line x1="300" y1="70" x2="220" y2="110" stroke="#333" stroke-width="2"/>
                        <line x1="300" y1="70" x2="380" y2="110" stroke="#333" stroke-width="2"/>
                        <circle cx="220" cy="110" r="20" fill="#f39c12" stroke="#2c3e50"/>
                        <text x="220" y="115" font-family="Arial" font-size="14" fill="white" text-anchor="middle">80</text>
                        <circle cx="380" cy="110" r="20" fill="#f39c12" stroke="#2c3e50"/>
                        <text x="380" y="115" font-family="Arial" font-size="14" fill="white" text-anchor="middle">70</text>
                        <line x1="220" y1="130" x2="180" y2="160" stroke="#333" stroke-width="2"/>
                        <line x1="220" y1="130" x2="260" y2="160" stroke="#333" stroke-width="2"/>
                        <circle cx="180" cy="160" r="20" fill="#27ae60" stroke="#2c3e50"/>
                        <text x="180" y="165" font-family="Arial" font-size="14" fill="white" text-anchor="middle">50</text>
                        <circle cx="260" cy="160" r="20" fill="#27ae60" stroke="#2c3e50"/>
                        <text x="260" y="165" font-family="Arial" font-size="14" fill="white" text-anchor="middle">40</text>
                        
                        <text x="450" y="50" font-family="Arial" font-size="14" fill="#333">Array Representation</text>
                        <rect x="450" y="70" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="465" y="87" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">0</text>
                        <rect x="480" y="70" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="495" y="87" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">1</text>
                        <rect x="510" y="70" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="525" y="87" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">2</text>
                        <rect x="540" y="70" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="555" y="87" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">3</text>
                        <rect x="570" y="70" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                        <text x="585" y="87" font-family="Arial" font-size="10" fill="#333" text-anchor="middle">4</text>

                        <rect x="450" y="95" width="30" height="25" fill="#e74c3c" stroke="#2c3e50"/>
                        <text x="465" y="112" font-family="Arial" font-size="10" fill="white" text-anchor="middle">90</text>
                        <rect x="480" y="95" width="30" height="25" fill="#f39c12" stroke="#2c3e50"/>
                        <text x="495" y="112" font-family="Arial" font-size="10" fill="white" text-anchor="middle">80</text>
                        <rect x="510" y="95" width="30" height="25" fill="#f39c12" stroke="#2c3e50"/>
                        <text x="525" y="112" font-family="Arial" font-size="10" fill="white" text-anchor="middle">70</text>
                        <rect x="540" y="95" width="30" height="25" fill="#27ae60" stroke="#2c3e50"/>
                        <text x="555" y="112" font-family="Arial" font-size="10" fill="white" text-anchor="middle">50</text>
                        <rect x="570" y="95" width="30" height="25" fill="#27ae60" stroke="#2c3e50"/>
                        <text x="585" y="112" font-family="Arial" font-size="10" fill="white" text-anchor="middle">40</text>
                    </svg>
                    <p class="svg-caption">Figure 6: A Max-Heap tree structure and its corresponding array representation. Note that every parent node is greater than its children.</p>
                </div>
            </div>
        </section>

    <div class="citation">
        <p><em>Reference: 2024 Exam Scheme & 2025 Handbook for CST201 Data Structures</em></p>
    </div>









    
    
</body>
</html>