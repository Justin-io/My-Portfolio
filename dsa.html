<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Justin-docs</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            line-height: 1.6;
            color: #333;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #fff;
        }
        
        .header {
            text-align: center;
            border-bottom: 3px solid #2c3e50;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.5em;
            color: #7f8c8d;
            margin-bottom: 5px;
        }
        
        .author {
            font-size: 1.1em;
            color: #95a5a6;
            font-style: italic;
        }
        
        .citation {
            font-size: 0.9em;
            color: #7f8c8d;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        .section {
            margin-bottom: 40px;
            page-break-inside: avoid;
        }
        
        .section-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 20px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        
        .concept {
            margin-bottom: 30px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #e74c3c;
        }
        
        .simple-explanation {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            border: 2px solid #27ae60;
        }
        
        .simple-title {
            font-weight: bold;
            color: #27ae60;
            margin-bottom: 10px;
        }
        
        .deep-explanation {
            background: #fff;
            padding: 15px;
            border-radius: 5px;
            border: 2px solid #3498db;
        }
        
        .deep-title {
            font-weight: bold;
            color: #3498db;
            margin-bottom: 10px;
        }
        
        .svg-container {
            text-align: center;
            margin: 20px 0;
            page-break-inside: avoid;
        }
        
        .svg-caption {
            font-size: 0.9em;
            color: #7f8c8d;
            text-align: center;
            margin-top: 10px;
            font-style: italic;
        }
        
        .formula {
            background: #f1f2f6;
            padding: 10px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 15px 0;
            border: 1px solid #ddd;
        }
        
        .example {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        
        .example-title {
            font-weight: bold;
            color: #856404;
            margin-bottom: 10px;
        }
        
        .code {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 15px 0;
        }
        
        @media print {
            body {
                font-size: 12pt;
                line-height: 1.4;
            }
            
            .header {
                page-break-after: avoid;
            }
            
            .section {
                page-break-inside: avoid;
                margin-bottom: 25px;
            }
            
            .concept {
                page-break-inside: avoid;
            }
            
            .svg-container {
                page-break-inside: avoid;
            }
            
            .title {
                font-size: 2em;
            }
            
            .section-title {
                font-size: 1.5em;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1 class="title">Justin-docs</h1>
        <h2 class="subtitle">Module 1: Introduction to Data Structures</h2>
        <p class="author">By Justin</p>
        <p class="citation">Based on 2024 Exam Scheme & 2025 Handbook Reference</p>
    </div>

    <div class="section">
        <h2 class="section-title">1. Data Types and Abstract Data Types</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üß∏ For a 5-Year-Old: What are Data Types?</div>
                <p>Imagine you have different toy boxes: one for LEGO blocks, one for stuffed animals, and one for toy cars. Each box holds only one type of toy. Data types are like these toy boxes - they tell the computer what kind of information you're storing, like numbers, words, or true/false answers!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üìö Formal Definition & Technical Details</div>
                <p><strong>Data Types</strong> are classifications that specify which type of value a variable can hold and what operations can be performed on it. In programming, data types define the size, range, and behavior of data stored in memory.</p>
                
                <div class="svg-container">
                    <svg width="600" height="300" viewBox="0 0 600 300" xmlns="http://www.w3.org/2000/svg">
                        <!-- Primitive Data Types -->
                        <rect x="50" y="50" width="120" height="80" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="110" y="85" text-anchor="middle" fill="white" font-weight="bold">INTEGER</text>
                        <text x="110" y="105" text-anchor="middle" fill="white" font-size="12">Whole numbers</text>
                        
                        <rect x="200" y="50" width="120" height="80" fill="#e74c3c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="260" y="85" text-anchor="middle" fill="white" font-weight="bold">FLOAT</text>
                        <text x="260" y="105" text-anchor="middle" fill="white" font-size="12">Decimal numbers</text>
                        
                        <rect x="350" y="50" width="120" height="80" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="410" y="85" text-anchor="middle" fill="white" font-weight="bold">CHARACTER</text>
                        <text x="410" y="105" text-anchor="middle" fill="white" font-size="12">Single letters</text>
                        
                        <!-- Derived Data Types -->
                        <rect x="125" y="160" width="120" height="80" fill="#f39c12" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="185" y="195" text-anchor="middle" fill="white" font-weight="bold">ARRAY</text>
                        <text x="185" y="215" text-anchor="middle" fill="white" font-size="12">Collection of items</text>
                        
                        <rect x="275" y="160" width="120" height="80" fill="#9b59b6" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="335" y="195" text-anchor="middle" fill="white" font-weight="bold">STRUCTURE</text>
                        <text x="335" y="215" text-anchor="middle" fill="white" font-size="12">Group of different types</text>
                        
                        <!-- Arrows showing relationships -->
                        <path d="M 110 130 L 185 160" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                        <path d="M 260 130 L 335 160" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                        
                        <!-- Arrow marker definition -->
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                            </marker>
                        </defs>
                        
                        <text x="300" y="30" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Data Types Classification</text>
                    </svg>
                    <div class="svg-caption">Figure 1: Classification of Primitive and Derived Data Types</div>
                </div>
                
                <p><strong>Primitive Data Types:</strong></p>
                <ul>
                    <li><strong>Integer:</strong> Whole numbers (e.g., 42, -17, 0)</li>
                    <li><strong>Float/Double:</strong> Decimal numbers (e.g., 3.14, -0.001)</li>
                    <li><strong>Character:</strong> Single letters or symbols (e.g., 'A', '$')</li>
                    <li><strong>Boolean:</strong> True or false values</li>
                </ul>
                
                <p><strong>Derived Data Types:</strong></p>
                <ul>
                    <li><strong>Array:</strong> Fixed-size collection of same-type elements</li>
                    <li><strong>Structure:</strong> Collection of different-type elements</li>
                    <li><strong>Pointer:</strong> Memory address reference</li>
                </ul>
            </div>
        </div>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üé≠ For a 5-Year-Old: What are Abstract Data Types?</div>
                <p>Think of a TV remote control. You don't need to know how the electronics inside work - you just need to know which buttons to press to change channels or adjust volume. Abstract Data Types are like remote controls - they show you what you can do (the buttons) but hide how it works inside!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîç Formal Definition & Technical Implementation</div>
                <p><strong>Abstract Data Types (ADTs)</strong> are mathematical models for data types where the data type is defined by its behavior (semantics) from the point of view of a user, specifically in terms of possible values, possible operations on data of this type, and the behavior of these operations.</p>
                
                <div class="svg-container">
                    <svg width="700" height="400" viewBox="0 0 700 400" xmlns="http://www.w3.org/2000/svg">
                        <!-- Interface Layer -->
                        <rect x="50" y="50" width="600" height="80" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="350" y="85" text-anchor="middle" fill="white" font-size="18" font-weight="bold">INTERFACE (What you can do)</text>
                        <text x="350" y="110" text-anchor="middle" fill="white" font-size="14">Operations: push(), pop(), isEmpty(), size()</text>
                        
                        <!-- Implementation Layer -->
                        <rect x="50" y="180" width="600" height="80" fill="#e74c3c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="350" y="215" text-anchor="middle" fill="white" font-size="18" font-weight="bold">IMPLEMENTATION (How it works)</text>
                        <text x="350" y="240" text-anchor="middle" fill="white" font-size="14">Array-based or Linked List-based storage</text>
                        
                        <!-- Data Layer -->
                        <rect x="50" y="310" width="600" height="80" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                        <text x="350" y="345" text-anchor="middle" fill="white" font-size="18" font-weight="bold">DATA (What's stored)</text>
                        <text x="350" y="370" text-anchor="middle" fill="white" font-size="14">Actual values in memory</text>
                        
                        <!-- Arrows showing abstraction -->
                        <path d="M 350 130 L 350 180" stroke="#2c3e50" stroke-width="3" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>
                        <path d="M 350 260 L 350 310" stroke="#2c3e50" stroke-width="3" fill="none" marker-end="url(#arrowhead)" stroke-dasharray="5,5"/>
                        
                        <!-- Arrow marker definition -->
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                            </marker>
                        </defs>
                        
                        <text x="350" y="30" text-anchor="middle" font-size="20" font-weight="bold" fill="#2c3e50">Abstract Data Type: Stack Example</text>
                    </svg>
                    <div class="svg-caption">Figure 2: ADT Abstraction Layers - Stack Example</div>
                </div>
                
                <p><strong>Key Characteristics of ADTs:</strong></p>
                <ul>
                    <li><strong>Encapsulation:</strong> Hides implementation details</li>
                    <li><strong>Abstraction:</strong> Focuses on what operations do, not how</li>
                    <li><strong>Modularity:</strong> Can be used independently of implementation</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üìù Real-World Example: Stack ADT</div>
                    <p><strong>Interface:</strong> push(item), pop(), peek(), isEmpty(), size()</p>
                    <p><strong>Implementation Options:</strong> Array-based, Linked List-based</p>
                    <p><strong>Real-world Analogy:</strong> Stack of plates - you can only add/remove from the top</p>
                </div>
                
                <div class="formula">
                    ADT = {Data Objects} ‚à™ {Operations} ‚à™ {Axioms}
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">2. Algorithm Analysis: Time and Space Complexity</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">‚è±Ô∏è For a 5-Year-Old: What is Algorithm Analysis?</div>
                <p>Imagine you have two ways to clean your room: one way takes 5 minutes, and another way takes 1 hour. Algorithm analysis is like figuring out which way is faster and which way uses more space in your toy box. We want to find the best way that's both fast and doesn't need too much space!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üìä Formal Definition & Mathematical Foundation</div>
                <p><strong>Algorithm Analysis</strong> is the process of determining the amount of time, storage, or other resources required to execute an algorithm. It helps us compare different algorithms and choose the most efficient one for a given problem.</p>
                
                <div class="svg-container">
                    <svg width="700" height="350" viewBox="0 0 700 350" xmlns="http://www.w3.org/2000/svg">
                        <!-- Coordinate system -->
                        <line x1="50" y1="300" x2="650" y2="300" stroke="#2c3e50" stroke-width="2"/>
                        <line x1="50" y1="50" x2="50" y2="300" stroke="#2c3e50" stroke-width="2"/>
                        
                        <!-- Labels -->
                        <text x="350" y="330" text-anchor="middle" font-size="14" fill="#2c3e50">Input Size (n)</text>
                        <text x="25" y="175" text-anchor="middle" font-size="14" fill="#2c3e50" transform="rotate(-90 25 175)">Time</text>
                        
                        <!-- O(1) - Constant -->
                        <line x1="50" y1="250" x2="650" y2="250" stroke="#27ae60" stroke-width="3"/>
                        <text x="660" y="255" font-size="12" fill="#27ae60">O(1)</text>
                        
                        <!-- O(log n) - Logarithmic -->
                        <path d="M 50 280 Q 150 260, 250 240 T 450 200 T 650 180" stroke="#3498db" stroke-width="3" fill="none"/>
                        <text x="660" y="185" font-size="12" fill="#3498db">O(log n)</text>
                        
                        <!-- O(n) - Linear -->
                        <line x1="50" y1="280" x2="650" y2="100" stroke="#f39c12" stroke-width="3"/>
                        <text x="660" y="105" font-size="12" fill="#f39c12">O(n)</text>
                        
                        <!-- O(n¬≤) - Quadratic -->
                        <path d="M 50 290 Q 200 250, 350 150 T 650 50" stroke="#e74c3c" stroke-width="3" fill="none"/>
                        <text x="660" y="55" font-size="12" fill="#e74c3c">O(n¬≤)</text>
                        
                        <!-- Title -->
                        <text x="350" y="30" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Time Complexity Growth Rates</text>
                    </svg>
                    <div class="svg-caption">Figure 3: Comparison of Different Time Complexity Functions</div>
                </div>
                
                <p><strong>Time Complexity:</strong> Measures how the runtime of an algorithm grows with input size.</p>
                <p><strong>Space Complexity:</strong> Measures how the memory usage grows with input size.</p>
                
                <div class="example">
                    <div class="example-title">üî¢ Frequency Count Method Example</div>
                    <div class="code">
for (i = 0; i < n; i++) {      // n+1 times
    for (j = 0; j < n; j++) {  // n*(n+1) times
        x = x + 1;             // n*n times
    }
}
                    </div>
                    <p><strong>Total Operations:</strong> (n+1) + n(n+1) + n¬≤ = 2n¬≤ + 2n + 1</p>
                    <p><strong>Time Complexity:</strong> O(n¬≤)</p>
                </div>
                
                <div class="formula">
                    T(n) = c‚ÇÅn¬≤ + c‚ÇÇn + c‚ÇÉ = O(n¬≤)
                </div>
                
                <p><strong>Best, Average, and Worst Case Analysis:</strong></p>
                <ul>
                    <li><strong>Best Case:</strong> Minimum time/space required (optimistic scenario)</li>
                    <li><strong>Average Case:</strong> Expected time/space over all possible inputs</li>
                    <li><strong>Worst Case:</strong> Maximum time/space required (pessimistic scenario)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">3. Asymptotic Notations: Big O, Omega, Theta</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üìà For a 5-Year-Old: What are Asymptotic Notations?</div>
                <p>Imagine you're growing a plant. Big O tells you "your plant won't grow taller than this tree." Omega tells you "your plant will grow at least as tall as this flower." Theta tells you "your plant will grow about as tall as this bush." These are just different ways to describe how big something gets!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üéØ Mathematical Definitions & Properties</div>
                <p><strong>Asymptotic Notations</strong> are mathematical tools used to describe the behavior of functions as their input approaches infinity. They provide a way to classify algorithms based on their growth rates.</p>
                
                <div class="svg-container">
                    <svg width="700" height="400" viewBox="0 0 700 400" xmlns="http://www.w3.org/2000/svg">
                        <!-- Big O Visualization -->
                        <g transform="translate(0, 0)">
                            <text x="350" y="30" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Big O Notation: f(n) = O(g(n))</text>
                            
                            <!-- Coordinate system -->
                            <line x1="50" y1="150" x2="650" y2="150" stroke="#2c3e50" stroke-width="1"/>
                            <line x1="50" y1="50" x2="50" y2="150" stroke="#2c3e50" stroke-width="1"/>
                            
                            <!-- g(n) = n¬≤ -->
                            <path d="M 50 140 Q 200 100, 350 60 T 650 50" stroke="#e74c3c" stroke-width="2" fill="none" stroke-dasharray="5,5"/>
                            <text x="660" y="55" font-size="12" fill="#e74c3c">g(n) = n¬≤</text>
                            
                            <!-- f(n) = 3n¬≤ + 2n + 1 -->
                            <path d="M 50 145 Q 200 110, 350 70 T 650 55" stroke="#3498db" stroke-width="3" fill="none"/>
                            <text x="660" y="60" font-size="12" fill="#3498db">f(n) = 3n¬≤ + 2n + 1</text>
                            
                            <!-- c*g(n) = 4n¬≤ -->
                            <path d="M 50 135 Q 200 90, 350 55 T 650 45" stroke="#27ae60" stroke-width="2" fill="none"/>
                            <text x="660" y="50" font-size="12" fill="#27ae60">c¬∑g(n) = 4n¬≤</text>
                            
                            <!-- n‚ÇÄ marker -->
                            <line x1="200" y1="50" x2="200" y2="150" stroke="#f39c12" stroke-width="2" stroke-dasharray="3,3"/>
                            <text x="200" y="165" text-anchor="middle" font-size="12" fill="#f39c12">n‚ÇÄ</text>
                        </g>
                        
                        <!-- Omega Visualization -->
                        <g transform="translate(0, 200)">
                            <text x="350" y="30" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Omega Notation: f(n) = Œ©(g(n))</text>
                            
                            <!-- Coordinate system -->
                            <line x1="50" y1="150" x2="650" y2="150" stroke="#2c3e50" stroke-width="1"/>
                            <line x1="50" y1="50" x2="50" y2="150" stroke="#2c3e50" stroke-width="1"/>
                            
                            <!-- g(n) = n -->
                            <path d="M 50 140 Q 350 100, 650 50" stroke="#e74c3c" stroke-width="2" fill="none" stroke-dasharray="5,5"/>
                            <text x="660" y="55" font-size="12" fill="#e74c3c">g(n) = n</text>
                            
                            <!-- f(n) = 2n + 3 -->
                            <path d="M 50 130 Q 350 80, 650 40" stroke="#3498db" stroke-width="3" fill="none"/>
                            <text x="660" y="45" font-size="12" fill="#3498db">f(n) = 2n + 3</text>
                            
                            <!-- c*g(n) = 1.5n -->
                            <path d="M 50 135 Q 350 90, 650 45" stroke="#27ae60" stroke-width="2" fill="none"/>
                            <text x="660" y="50" font-size="12" fill="#27ae60">c¬∑g(n) = 1.5n</text>
                            
                            <!-- n‚ÇÄ marker -->
                            <line x1="150" y1="50" x2="150" y2="150" stroke="#f39c12" stroke-width="2" stroke-dasharray="3,3"/>
                            <text x="150" y="165" text-anchor="middle" font-size="12" fill="#f39c12">n‚ÇÄ</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 4: Big O and Omega Notations Visualized</div>
                </div>
                
                <p><strong>Big O Notation (O):</strong> Upper bound</p>
                <div class="formula">
                    f(n) = O(g(n)) if ‚àÉ positive constants c and n‚ÇÄ such that 0 ‚â§ f(n) ‚â§ c¬∑g(n) for all n ‚â• n‚ÇÄ
                </div>
                
                <p><strong>Omega Notation (Œ©):</strong> Lower bound</p>
                <div class="formula">
                    f(n) = Œ©(g(n)) if ‚àÉ positive constants c and n‚ÇÄ such that 0 ‚â§ c¬∑g(n) ‚â§ f(n) for all n ‚â• n‚ÇÄ
                </div>
                
                <p><strong>Theta Notation (Œò):</strong> Tight bound</p>
                <div class="formula">
                    f(n) = Œò(g(n)) if ‚àÉ positive constants c‚ÇÅ, c‚ÇÇ, and n‚ÇÄ such that 0 ‚â§ c‚ÇÅ¬∑g(n) ‚â§ f(n) ‚â§ c‚ÇÇ¬∑g(n) for all n ‚â• n‚ÇÄ
                </div>
                
                <div class="example">
                    <div class="example-title">üìä Practical Example: Analyzing f(n) = 3n¬≤ + 2n + 1</div>
                    <p><strong>Big O:</strong> f(n) = O(n¬≤) because 3n¬≤ + 2n + 1 ‚â§ 4n¬≤ for n ‚â• 3</p>
                    <p><strong>Omega:</strong> f(n) = Œ©(n¬≤) because 3n¬≤ + 2n + 1 ‚â• 3n¬≤ for n ‚â• 1</p>
                    <p><strong>Theta:</strong> f(n) = Œò(n¬≤) because 3n¬≤ ‚â§ 3n¬≤ + 2n + 1 ‚â§ 4n¬≤ for n ‚â• 3</p>
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">4. Recursion and its Applications</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üîÑ For a 5-Year-Old: What is Recursion?</div>
                <p>Imagine you have a Russian nesting doll. When you open it, you find a smaller doll inside. When you open that one, you find an even smaller doll! This keeps happening until you find the tiniest doll that can't be opened. Recursion is like this - a function that calls itself until it reaches the smallest version!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üß© Formal Definition & Implementation</div>
                <p><strong>Recursion</strong> is a programming technique where a function calls itself directly or indirectly to solve a problem by breaking it down into smaller, similar subproblems.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- Recursive Function Call Stack -->
                        <g transform="translate(50, 50)">
                            <text x="300" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Recursive Function Call Stack: factorial(4)</text>
                            
                            <!-- Stack frames -->
                            <rect x="100" y="30" width="400" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="55" text-anchor="middle" fill="white" font-weight="bold">factorial(4)</text>
                            <text x="300" y="75" text-anchor="middle" fill="white">return 4 * factorial(3)</text>
                            
                            <rect x="100" y="100" width="400" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="125" text-anchor="middle" fill="white" font-weight="bold">factorial(3)</text>
                            <text x="300" y="145" text-anchor="middle" fill="white">return 3 * factorial(2)</text>
                            
                            <rect x="100" y="170" width="400" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="195" text-anchor="middle" fill="white" font-weight="bold">factorial(2)</text>
                            <text x="300" y="215" text-anchor="middle" fill="white">return 2 * factorial(1)</text>
                            
                            <rect x="100" y="240" width="400" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="265" text-anchor="middle" fill="white" font-weight="bold">factorial(1)</text>
                            <text x="300" y="285" text-anchor="middle" fill="white">return 1 * factorial(0)</text>
                            
                            <!-- Base case -->
                            <rect x="100" y="310" width="400" height="60" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="300" y="335" text-anchor="middle" fill="white" font-weight="bold">factorial(0)</text>
                            <text x="300" y="355" text-anchor="middle" fill="white">return 1 (Base Case)</text>
                            
                            <!-- Arrows showing call flow -->
                            <path d="M 300 90 L 300 100" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 300 160 L 300 170" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 300 230 L 300 240" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            <path d="M 300 300 L 300 310" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Return arrows -->
                            <path d="M 450 340 L 450 280" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)" stroke-dasharray="3,3"/>
                            <path d="M 450 210 L 450 150" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)" stroke-dasharray="3,3"/>
                            <path d="M 450 140 L 450 80" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)" stroke-dasharray="3,3"/>
                            <path d="M 450 70 L 450 10" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)" stroke-dasharray="3,3"/>
                            
                            <!-- Arrow markers -->
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                                </marker>
                                <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                                </marker>
                            </defs>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 5: Recursive Function Call Stack for Factorial(4)</div>
                </div>
                
                <p><strong>Essential Components of Recursion:</strong></p>
                <ul>
                    <li><strong>Base Case:</strong> The condition that stops the recursion</li>
                    <li><strong>Recursive Case:</strong> The part where the function calls itself</li>
                    <li><strong>Call Stack:</strong> Memory stack that tracks function calls</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Recursive Factorial Implementation</div>
                    <div class="code">
function factorial(n) {
    // Base case
    if (n == 0 || n == 1) {
        return 1;
    }
    // Recursive case
    else {
        return n * factorial(n - 1);
    }
}
                    </div>
                    <p><strong>Time Complexity:</strong> O(n)</p>
                    <p><strong>Space Complexity:</strong> O(n) due to call stack</p>
                </div>
                
                <p><strong>Applications of Recursion:</strong></p>
                <ul>
                    <li><strong>Tree Traversal:</strong> Inorder, Preorder, Postorder</li>
                    <li><strong>Divide and Conquer:</strong> Merge Sort, Quick Sort</li>
                    <li><strong>Dynamic Programming:</strong> Fibonacci, Coin Change</li>
                    <li><strong>Graph Algorithms:</strong> DFS, Topological Sort</li>
                    <li><strong>Mathematical Computations:</strong> Factorial, Power, GCD</li>
                </ul>
                
                <div class="formula">
                    T(n) = T(n-1) + O(1) = O(n)  // For simple linear recursion
                </div>
                
                <p><strong>Advantages:</strong></p>
                <ul>
                    <li>Elegant and concise code for complex problems</li>
                    <li>Natural fit for problems with recursive structure</li>
                    <li>Reduces code duplication</li>
                </ul>
                
                <p><strong>Disadvantages:</strong></p>
                <ul>
                    <li>Can be less efficient than iterative solutions</li>
                    <li>Risk of stack overflow for deep recursion</li>
                    <li>Can be harder to debug and understand</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">Module Summary & Exam Focus</h2>
        
        <div class="concept">
            <div class="deep-explanation">
                <div class="deep-title">üéØ Key Exam Topics from Module 1</div>
                
                <p><strong>High-Frequency Exam Questions:</strong></p>
                <ol>
                    <li><strong>Algorithm Analysis using Frequency Count:</strong>
                        <ul>
                            <li>Calculate time complexity of nested loops</li>
                            <li>Analyze recursive algorithms</li>
                            <li>Compare different algorithmic approaches</li>
                        </ul>
                    </li>
                    
                    <li><strong>Asymptotic Notations:</strong>
                        <ul>
                            <li>Prove Big O, Omega, Theta for given functions</li>
                            <li>Compare growth rates of different functions</li>
                            <li>Derive complexity bounds for algorithms</li>
                        </ul>
                    </li>
                    
                    <li><strong>ADT Implementation:</strong>
                        <ul>
                            <li>Design ADTs for specific problems</li>
                            <li>Compare different implementations</li>
                            <li>Analyze trade-offs between implementations</li>
                        </ul>
                    </li>
                    
                    <li><strong>Recursive Algorithm Design:</strong>
                        <ul>
                            <li>Write recursive solutions for problems</li>
                            <li>Analyze time and space complexity</li>
                            <li>Convert recursive to iterative solutions</li>
                        </ul>
                    </li>
                </ol>
                
                <div class="example">
                    <div class="example-title">üìù Sample Exam Question</div>
                    <p><strong>Question:</strong> Calculate the frequency count and time complexity of the following code segment:</p>
                    <div class="code">
for (i = 0; i < n; i++) {
    for (j = 0; j < i; j++) {
        for (k = 0; k < j; k++) {
            x = x + 1;
        }
    }
}
                    </div>
                    <p><strong>Solution Approach:</strong>
                    <br>1. Innermost loop (k): runs j times
                    <br>2. Middle loop (j): runs i times
                    <br>3. Outer loop (i): runs n times
                    <br>4. Total operations: Œ£(i=0 to n-1) Œ£(j=0 to i-1) j = Œ£(i=0 to n-1) i(i-1)/2 = O(n¬≥)</p>
                </div>
                
                <p><strong>Study Strategy:</strong></p>
                <ul>
                    <li>Master the frequency count method for complexity analysis</li>
                    <li>Practice proving asymptotic notations mathematically</li>
                    <li>Understand the relationship between data types and ADTs</li>
                    <li>Develop intuition for recursive problem-solving</li>
                    <li>Work through examples from previous year papers</li>
                </ul>
                
                <div class="formula">
                    Exam Success = Understanding + Practice + Application
                </div>
            </div>
        </div>
    </div>
    <div class="header">
        <h2 class="subtitle">Module 2: Arrays and Linked Lists</h2>
    </div>

    <div class="section">
        <h2 class="section-title">1. Linear Arrays and Operations</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üìö For a 5-Year-Old: What are Arrays?</div>
                <p>Imagine you have a row of numbered boxes, and each box can hold one toy. You can quickly find any toy by looking at its box number! Arrays are like these numbered boxes - they help us store many things in order and find them easily by their position.</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîç Formal Definition & Technical Implementation</div>
                <p><strong>Arrays</strong> are contiguous memory locations that store elements of the same data type. Each element can be accessed directly using its index, which represents its position in the array.</p>
                
                <div class="svg-container">
                    <svg width="700" height="300" viewBox="0 0 700 300" xmlns="http://www.w3.org/2000/svg">
                        <!-- Array representation -->
                        <g transform="translate(50, 50)">
                            <text x="300" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Linear Array Structure</text>
                            
                            <!-- Memory blocks -->
                            <rect x="0" y="30" width="80" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="40" y="55" text-anchor="middle" fill="white" font-weight="bold">10</text>
                            <text x="40" y="75" text-anchor="middle" fill="white" font-size="12">arr[0]</text>
                            
                            <rect x="90" y="30" width="80" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="130" y="55" text-anchor="middle" fill="white" font-weight="bold">25</text>
                            <text x="130" y="75" text-anchor="middle" fill="white" font-size="12">arr[1]</text>
                            
                            <rect x="180" y="30" width="80" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="220" y="55" text-anchor="middle" fill="white" font-weight="bold">17</text>
                            <text x="220" y="75" text-anchor="middle" fill="white" font-size="12">arr[2]</text>
                            
                            <rect x="270" y="30" width="80" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="310" y="55" text-anchor="middle" fill="white" font-weight="bold">42</text>
                            <text x="310" y="75" text-anchor="middle" fill="white" font-size="12">arr[3]</text>
                            
                            <rect x="360" y="30" width="80" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="400" y="55" text-anchor="middle" fill="white" font-weight="bold">8</text>
                            <text x="400" y="75" text-anchor="middle" fill="white" font-size="12">arr[4]</text>
                            
                            <rect x="450" y="30" width="80" height="60" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="490" y="55" text-anchor="middle" fill="white" font-weight="bold">33</text>
                            <text x="490" y="75" text-anchor="middle" fill="white" font-size="12">arr[5]</text>
                            
                            <!-- Memory addresses -->
                            <text x="40" y="110" text-anchor="middle" font-size="10" fill="#7f8c8d">1000</text>
                            <text x="130" y="110" text-anchor="middle" font-size="10" fill="#7f8c8d">1004</text>
                            <text x="220" y="110" text-anchor="middle" font-size="10" fill="#7f8c8d">1008</text>
                            <text x="310" y="110" text-anchor="middle" font-size="10" fill="#7f8c8d">1012</text>
                            <text x="400" y="110" text-anchor="middle" font-size="10" fill="#7f8c8d">1016</text>
                            <text x="490" y="110" text-anchor="middle" font-size="10" fill="#7f8c8d">1020</text>
                            
                            <!-- Index labels -->
                            <text x="40" y="130" text-anchor="middle" font-size="12" fill="#e74c3c">Index 0</text>
                            <text x="130" y="130" text-anchor="middle" font-size="12" fill="#e74c3c">Index 1</text>
                            <text x="220" y="130" text-anchor="middle" font-size="12" fill="#e74c3c">Index 2</text>
                            <text x="310" y="130" text-anchor="middle" font-size="12" fill="#e74c3c">Index 3</text>
                            <text x="400" y="130" text-anchor="middle" font-size="12" fill="#e74c3c">Index 4</text>
                            <text x="490" y="130" text-anchor="middle" font-size="12" fill="#e74c3c">Index 5</text>
                            
                            <!-- Base address pointer -->
                            <path d="M 40 20 L 40 30" stroke="#e74c3c" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
                            <text x="40" y="15" text-anchor="middle" font-size="12" fill="#e74c3c" font-weight="bold">Base Address</text>
                        </g>
                        
                        <!-- Arrow marker definition -->
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>
                    </svg>
                    <div class="svg-caption">Figure 1: Linear Array Memory Representation</div>
                </div>
                
                <p><strong>Key Characteristics:</strong></p>
                <ul>
                    <li><strong>Fixed Size:</strong> Size determined at declaration</li>
                    <li><strong>Homogeneous:</strong> All elements same data type</li>
                    <li><strong>Random Access:</strong> O(1) access time using index</li>
                    <li><strong>Contiguous Memory:</strong> Elements stored in consecutive locations</li>
                </ul>
                
                <p><strong>Array Operations:</strong></p>
                <ul>
                    <li><strong>Access:</strong> arr[i] - O(1) time complexity</li>
                    <li><strong>Insertion:</strong> O(n) in worst case (shifting required)</li>
                    <li><strong>Deletion:</strong> O(n) in worst case (shifting required)</li>
                    <li><strong>Search:</strong> O(n) for linear search, O(log n) for binary search (if sorted)</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Array Operations Implementation</div>
                    <div class="code">
// Array declaration and initialization
int arr[5] = {10, 20, 30, 40, 50};

// Access element
int element = arr[2];  // O(1)

// Insert element at position i (requires shifting)
void insert(int arr[], int n, int pos, int value) {
    for (int i = n; i > pos; i--) {
        arr[i] = arr[i-1];  // Shift elements
    }
    arr[pos] = value;  // Insert new element
}

// Delete element at position i (requires shifting)
void delete(int arr[], int n, int pos) {
    for (int i = pos; i < n-1; i++) {
        arr[i] = arr[i+1];  // Shift elements
    }
}
                    </div>
                </div>
                
                <div class="formula">
                    Address of arr[i] = Base Address + (i √ó size_of_element)
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">2. Sparse Matrices</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üéØ For a 5-Year-Old: What are Sparse Matrices?</div>
                <p>Imagine a big chessboard where most squares are empty and only a few have pieces. Instead of remembering every empty square, we can just write down where the pieces are! Sparse matrices are like this - they're mostly empty, so we only remember where the important numbers are.</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üìä Formal Definition & Representation Methods</div>
                <p><strong>Sparse Matrices</strong> are matrices in which most elements are zero. Instead of storing all elements (including zeros), we use special representations that store only non-zero elements and their positions.</p>
                
                <div class="svg-container">
                    <svg width="700" height="400" viewBox="0 0 700 400" xmlns="http://www.w3.org/2000/svg">
                        <!-- Original Sparse Matrix -->
                        <g transform="translate(50, 50)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Original Sparse Matrix (5√ó5)</text>
                            
                            <!-- Matrix grid -->
                            <g transform="translate(20, 20)">
                                <!-- Row 0 -->
                                <rect x="0" y="0" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="15" y="20" text-anchor="middle" font-size="14">3</text>
                                
                                <rect x="30" y="0" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="20" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="60" y="0" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="20" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="90" y="0" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="20" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="120" y="0" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="20" text-anchor="middle" font-size="14">7</text>
                                
                                <!-- Row 1 -->
                                <rect x="0" y="30" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="15" y="50" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="30" y="30" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="50" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="60" y="30" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="50" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="90" y="30" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="50" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="120" y="30" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="50" text-anchor="middle" font-size="14">0</text>
                                
                                <!-- Row 2 -->
                                <rect x="0" y="60" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="15" y="80" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="30" y="60" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="80" text-anchor="middle" font-size="14">1</text>
                                
                                <rect x="60" y="60" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="80" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="90" y="60" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="80" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="120" y="60" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="80" text-anchor="middle" font-size="14">0</text>
                                
                                <!-- Row 3 -->
                                <rect x="0" y="90" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="15" y="110" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="30" y="90" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="110" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="60" y="90" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="110" text-anchor="middle" font-size="14">5</text>
                                
                                <rect x="90" y="90" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="110" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="120" y="90" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="110" text-anchor="middle" font-size="14">0</text>
                                
                                <!-- Row 4 -->
                                <rect x="0" y="120" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="15" y="140" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="30" y="120" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="140" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="60" y="120" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="140" text-anchor="middle" font-size="14">0</text>
                                
                                <rect x="90" y="120" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="140" text-anchor="middle" font-size="14">2</text>
                                
                                <rect x="120" y="120" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="140" text-anchor="middle" font-size="14">0</text>
                            </g>
                        </g>
                        
                        <!-- Arrow -->
                        <path d="M 350 150 L 350 200" stroke="#e74c3c" stroke-width="3" fill="none" marker-end="url(#arrowhead)"/>
                        
                        <!-- Coordinate List Representation -->
                        <g transform="translate(250, 220)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Coordinate List (COO)</text>
                            
                            <!-- Table -->
                            <rect x="20" y="20" width="60" height="30" fill="#3498db" stroke="#2c3e50"/>
                            <text x="50" y="40" text-anchor="middle" fill="white">Row</text>
                            
                            <rect x="80" y="20" width="60" height="30" fill="#3498db" stroke="#2c3e50"/>
                            <text x="110" y="40" text-anchor="middle" fill="white">Col</text>
                            
                            <rect x="140" y="20" width="60" height="30" fill="#3498db" stroke="#2c3e50"/>
                            <text x="170" y="40" text-anchor="middle" fill="white">Value</text>
                            
                            <!-- Data rows -->
                            <rect x="20" y="50" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="50" y="67" text-anchor="middle">0</text>
                            
                            <rect x="80" y="50" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="110" y="67" text-anchor="middle">0</text>
                            
                            <rect x="140" y="50" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="170" y="67" text-anchor="middle">3</text>
                            
                            <rect x="20" y="75" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="50" y="92" text-anchor="middle">0</text>
                            
                            <rect x="80" y="75" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="110" y="92" text-anchor="middle">4</text>
                            
                            <rect x="140" y="75" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="170" y="92" text-anchor="middle">7</text>
                            
                            <rect x="20" y="100" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="50" y="117" text-anchor="middle">2</text>
                            
                            <rect x="80" y="100" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="110" y="117" text-anchor="middle">1</text>
                            
                            <rect x="140" y="100" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="170" y="117" text-anchor="middle">1</text>
                            
                            <rect x="20" y="125" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="50" y="142" text-anchor="middle">3</text>
                            
                            <rect x="80" y="125" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="110" y="142" text-anchor="middle">2</text>
                            
                            <rect x="140" y="125" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="170" y="142" text-anchor="middle">5</text>
                            
                            <rect x="20" y="150" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="50" y="167" text-anchor="middle">4</text>
                            
                            <rect x="80" y="150" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="110" y="167" text-anchor="middle">3</text>
                            
                            <rect x="140" y="150" width="60" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="170" y="167" text-anchor="middle">2</text>
                        </g>
                        
                        <!-- Arrow marker definition -->
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>
                    </svg>
                    <div class="svg-caption">Figure 2: Sparse Matrix and its Coordinate List Representation</div>
                </div>
                
                <p><strong>Representation Methods:</strong></p>
                <ul>
                    <li><strong>Coordinate List (COO):</strong> Stores (row, column, value) tuples</li>
                    <li><strong>Compressed Sparse Row (CSR):</strong> Uses three arrays for values, column indices, and row pointers</li>
                    <li><strong>Compressed Sparse Column (CSC):</strong> Similar to CSR but column-oriented</li>
                    <li><strong>Diagonal Storage:</strong> For matrices with non-zero elements only on diagonals</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíæ Memory Efficiency Comparison</div>
                    <p><strong>Traditional Storage:</strong> 5√ó5 matrix = 25 elements</p>
                    <p><strong>Sparse Storage (COO):</strong> 5 non-zero elements √ó 3 values = 15 elements</p>
                    <p><strong>Space Saved:</strong> 40% (for this example)</p>
                    <p><strong>Sparsity:</strong> (Number of zeros) / (Total elements) = 20/25 = 80%</p>
                </div>
                
                <div class="formula">
                    Sparsity = (Number of zero elements) / (Total elements)
                    <br>
                    Storage Efficiency = (Non-zero elements √ó 3) / (Rows √ó Columns)
                </div>
                
                <p><strong>Applications:</strong></p>
                <ul>
                    <li>Finite element analysis</li>
                    <li>Graph theory (adjacency matrices)</li>
                    <li>Machine learning (feature matrices)</li>
                    <li>Image processing (transform matrices)</li>
                </ul>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">3. Stacks: Operations and Applications</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">ü•û For a 5-Year-Old: What is a Stack?</div>
                <p>Imagine a stack of pancakes! You can only add a new pancake on top, and you can only take the top pancake off. You can't take a pancake from the middle without removing all the ones above it first. A stack in computers works exactly like this - you add and remove things only from the top!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üìö Formal Definition & Implementation</div>
                <p><strong>Stack</strong> is a linear data structure that follows the LIFO (Last-In-First-Out) principle. Elements are added and removed from the same end, called the "top" of the stack.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- Stack Operations Visualization -->
                        <g transform="translate(50, 50)">
                            <text x="300" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Stack Operations: LIFO Principle</text>
                            
                            <!-- Initial Stack -->
                            <g transform="translate(50, 50)">
                                <text x="50" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#2c3e50">Initial Stack</text>
                                
                                <rect x="0" y="20" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="45" text-anchor="middle" fill="white" font-weight="bold">10</text>
                                
                                <rect x="0" y="60" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="85" text-anchor="middle" fill="white" font-weight="bold">20</text>
                                
                                <rect x="0" y="100" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="125" text-anchor="middle" fill="white" font-weight="bold">30</text>
                                
                                <rect x="0" y="140" width="100" height="40" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="165" text-anchor="middle" fill="white" font-weight="bold">40</text>
                                
                                <text x="50" y="195" text-anchor="middle" font-size="12" fill="#e74c3c">TOP</text>
                            </g>
                            
                            <!-- Push Operation -->
                            <g transform="translate(200, 50)">
                                <text x="50" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#2c3e50">Push(50)</text>
                                
                                <rect x="0" y="20" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="45" text-anchor="middle" fill="white" font-weight="bold">10</text>
                                
                                <rect x="0" y="60" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="85" text-anchor="middle" fill="white" font-weight="bold">20</text>
                                
                                <rect x="0" y="100" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="125" text-anchor="middle" fill="white" font-weight="bold">30</text>
                                
                                <rect x="0" y="140" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="165" text-anchor="middle" fill="white" font-weight="bold">40</text>
                                
                                <rect x="0" y="180" width="100" height="40" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="205" text-anchor="middle" fill="white" font-weight="bold">50</text>
                                
                                <text x="50" y="235" text-anchor="middle" font-size="12" fill="#27ae60">TOP</text>
                                
                                <!-- Arrow showing push -->
                                <path d="M 120 200 L 140 200" stroke="#27ae60" stroke-width="3" fill="none" marker-end="url(#arrowhead-green)"/>
                                <text x="130" y="195" text-anchor="middle" font-size="10" fill="#27ae60">push</text>
                            </g>
                            
                            <!-- Pop Operation -->
                            <g transform="translate(350, 50)">
                                <text x="50" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#2c3e50">Pop()</text>
                                
                                <rect x="0" y="20" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="45" text-anchor="middle" fill="white" font-weight="bold">10</text>
                                
                                <rect x="0" y="60" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="85" text-anchor="middle" fill="white" font-weight="bold">20</text>
                                
                                <rect x="0" y="100" width="100" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="125" text-anchor="middle" fill="white" font-weight="bold">30</text>
                                
                                <rect x="0" y="140" width="100" height="40" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="50" y="165" text-anchor="middle" fill="white" font-weight="bold">40</text>
                                
                                <text x="50" y="195" text-anchor="middle" font-size="12" fill="#e74c3c">TOP</text>
                                
                                <!-- Arrow showing pop -->
                                <path d="M 50 180 L 50 250" stroke="#e74c3c" stroke-width="3" fill="none" marker-end="url(#arrowhead-red)"/>
                                <text x="70" y="215" font-size="10" fill="#e74c3c">pop</text>
                            </g>
                            
                            <!-- Stack Operations Table -->
                            <g transform="translate(50, 300)">
                                <text x="200" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Stack Operations and Time Complexity</text>
                                
                                <!-- Table header -->
                                <rect x="0" y="20" width="150" height="30" fill="#34495e" stroke="#2c3e50"/>
                                <text x="75" y="40" text-anchor="middle" fill="white" font-weight="bold">Operation</text>
                                
                                <rect x="150" y="20" width="150" height="30" fill="#34495e" stroke="#2c3e50"/>
                                <text x="225" y="40" text-anchor="middle" fill="white" font-weight="bold">Description</text>
                                
                                <rect x="300" y="20" width="100" height="30" fill="#34495e" stroke="#2c3e50"/>
                                <text x="350" y="40" text-anchor="middle" fill="white" font-weight="bold">Time</text>
                                
                                <!-- Push -->
                                <rect x="0" y="50" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="67" text-anchor="middle">push(item)</text>
                                
                                <rect x="150" y="50" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="225" y="67" text-anchor="middle">Add item to top</text>
                                
                                <rect x="300" y="50" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="350" y="67" text-anchor="middle">O(1)</text>
                                
                                <!-- Pop -->
                                <rect x="0" y="75" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="92" text-anchor="middle">pop()</text>
                                
                                <rect x="150" y="75" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="225" y="92" text-anchor="middle">Remove from top</text>
                                
                                <rect x="300" y="75" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="350" y="92" text-anchor="middle">O(1)</text>
                                
                                <!-- Peek -->
                                <rect x="0" y="100" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="117" text-anchor="middle">peek()</text>
                                
                                <rect x="150" y="100" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="225" y="117" text-anchor="middle">View top element</text>
                                
                                <rect x="300" y="100" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="350" y="117" text-anchor="middle">O(1)</text>
                                
                                <!-- isEmpty -->
                                <rect x="0" y="125" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="142" text-anchor="middle">isEmpty()</text>
                                
                                <rect x="150" y="125" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="225" y="142" text-anchor="middle">Check if empty</text>
                                
                                <rect x="300" y="125" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="350" y="142" text-anchor="middle">O(1)</text>
                            </g>
                        </g>
                        
                        <!-- Arrow markers -->
                        <defs>
                            <marker id="arrowhead-green" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#27ae60"/>
                            </marker>
                            <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>
                    </svg>
                    <div class="svg-caption">Figure 3: Stack Operations and LIFO Principle</div>
                </div>
                
                <p><strong>Stack Implementation Methods:</strong></p>
                <ul>
                    <li><strong>Array-based Stack:</strong> Uses fixed-size array with top pointer</li>
                    <li><strong>Linked List-based Stack:</strong> Uses dynamic linked list with head as top</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Array-based Stack Implementation</div>
                    <div class="code">
#define MAX_SIZE 100

typedef struct {
    int items[MAX_SIZE];
    int top;
} Stack;

// Initialize stack
void init(Stack *s) {
    s->top = -1;
}

// Push operation
int push(Stack *s, int item) {
    if (s->top == MAX_SIZE - 1) {
        return 0; // Stack overflow
    }
    s->items[++s->top] = item;
    return 1;
}

// Pop operation
int pop(Stack *s, int *item) {
    if (s->top == -1) {
        return 0; // Stack underflow
    }
    *item = s->items[s->top--];
    return 1;
}

// Peek operation
int peek(Stack *s, int *item) {
    if (s->top == -1) {
        return 0; // Stack empty
    }
    *item = s->items[s->top];
    return 1;
}
                    </div>
                </div>
                
                <p><strong>Applications of Stacks:</strong></p>
                <ul>
                    <li><strong>Expression Evaluation:</strong> Postfix, prefix, infix expressions</li>
                    <li><strong>Function Call Management:</strong> Call stack in programming languages</li>
                    <li><strong>Undo/Redo Operations:</strong> In text editors and applications</li>
                    <li><strong>Backtracking Algorithms:</strong> DFS, maze solving</li>
                    <li><strong>Memory Management:</strong> Stack memory allocation</li>
                </ul>
                
                <div class="formula">
                    Stack Capacity = Array Size (for array-based)
                    <br>
                    Time Complexity: All operations = O(1)
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">4. Queues: Types, Operations, and Applications</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üö∂‚Äç‚ôÇÔ∏è For a 5-Year-Old: What is a Queue?</div>
                <p>Imagine you're waiting in line for ice cream! The first person who gets in line gets their ice cream first, and new people join at the back. A queue in computers works just like this - the first item that goes in is the first one that comes out!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîÑ Formal Definition & Queue Types</div>
                <p><strong>Queue</strong> is a linear data structure that follows the FIFO (First-In-First-Out) principle. Elements are added at the rear and removed from the front.</p>
                
                <div class="svg-container">
                    <svg width="700" height="600" viewBox="0 0 700 600" xmlns="http://www.w3.org/2000/svg">
                        <!-- Simple Queue -->
                        <g transform="translate(50, 50)">
                            <text x="250" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Simple Queue: FIFO Principle</text>
                            
                            <!-- Queue visualization -->
                            <rect x="50" y="30" width="60" height="50" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="80" y="60" text-anchor="middle" fill="white" font-weight="bold">10</text>
                            
                            <rect x="110" y="30" width="60" height="50" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="140" y="60" text-anchor="middle" fill="white" font-weight="bold">20</text>
                            
                            <rect x="170" y="30" width="60" height="50" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="200" y="60" text-anchor="middle" fill="white" font-weight="bold">30</text>
                            
                            <rect x="230" y="30" width="60" height="50" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="260" y="60" text-anchor="middle" fill="white" font-weight="bold">40</text>
                            
                            <rect x="290" y="30" width="60" height="50" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="320" y="60" text-anchor="middle" fill="white" font-weight="bold">50</text>
                            
                            <!-- Front and Rear pointers -->
                            <path d="M 80 90 L 80 110" stroke="#27ae60" stroke-width="3" fill="none" marker-end="url(#arrowhead-green)"/>
                            <text x="80" y="125" text-anchor="middle" font-size="12" fill="#27ae60" font-weight="bold">FRONT</text>
                            
                            <path d="M 320 90 L 320 110" stroke="#e74c3c" stroke-width="3" fill="none" marker-end="url(#arrowhead-red)"/>
                            <text x="320" y="125" text-anchor="middle" font-size="12" fill="#e74c3c" font-weight="bold">REAR</text>
                            
                            <!-- Enqueue operation -->
                            <path d="M 350 55 L 380 55" stroke="#27ae60" stroke-width="3" fill="none" marker-end="url(#arrowhead-green)"/>
                            <text x="365" y="50" text-anchor="middle" font-size="10" fill="#27ae60">enqueue</text>
                            
                            <!-- Dequeue operation -->
                            <path d="M 30 55 L 50 55" stroke="#e74c3c" stroke-width="3" fill="none" marker-end="url(#arrowhead-red)"/>
                            <text x="15" y="50" text-anchor="middle" font-size="10" fill="#e74c3c">dequeue</text>
                        </g>
                        
                        <!-- Circular Queue -->
                        <g transform="translate(50, 200)">
                            <text x="250" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Circular Queue</text>
                            
                            <!-- Circular representation -->
                            <circle cx="250" cy="80" r="60" fill="none" stroke="#2c3e50" stroke-width="2"/>
                            
                            <!-- Queue elements in circle -->
                            <rect x="235" y="25" width="30" height="20" fill="#3498db" stroke="#2c3e50"/>
                            <text x="250" y="40" text-anchor="middle" fill="white" font-size="12">10</text>
                            
                            <rect x="280" y="40" width="30" height="20" fill="#3498db" stroke="#2c3e50"/>
                            <text x="295" y="55" text-anchor="middle" fill="white" font-size="12">20</text>
                            
                            <rect x="290" y="75" width="30" height="20" fill="#3498db" stroke="#2c3e50"/>
                            <text x="305" y="90" text-anchor="middle" fill="white" font-size="12">30</text>
                            
                            <rect x="280" y="110" width="30" height="20" fill="#e74c3c" stroke="#2c3e50"/>
                            <text x="295" y="125" text-anchor="middle" fill="white" font-size="12">40</text>
                            
                            <rect x="235" y="125" width="30" height="20" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="250" y="140" text-anchor="middle" fill="#7f8c8d" font-size="12">empty</text>
                            
                            <rect x="190" y="110" width="30" height="20" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="205" y="125" text-anchor="middle" fill="#7f8c8d" font-size="12">empty</text>
                            
                            <!-- Front and Rear pointers -->
                            <path d="M 250 15 L 250 5" stroke="#27ae60" stroke-width="3" fill="none" marker-end="url(#arrowhead-green)"/>
                            <text x="250" y="0" text-anchor="middle" font-size="12" fill="#27ae60" font-weight="bold">FRONT</text>
                            
                            <path d="M 305 150 L 305 160" stroke="#e74c3c" stroke-width="3" fill="none" marker-end="url(#arrowhead-red)"/>
                            <text x="305" y="175" text-anchor="middle" font-size="12" fill="#e74c3c" font-weight="bold">REAR</text>
                        </g>
                        
                        <!-- Priority Queue -->
                        <g transform="translate(50, 380)">
                            <text x="250" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Priority Queue</text>
                            
                            <!-- Priority levels -->
                            <rect x="50" y="30" width="400" height="40" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="250" y="55" text-anchor="middle" fill="white" font-weight="bold">Priority 1: Emergency (5)</text>
                            
                            <rect x="50" y="70" width="400" height="40" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="250" y="95" text-anchor="middle" fill="white" font-weight="bold">Priority 2: High (3, 7)</text>
                            
                            <rect x="50" y="110" width="400" height="40" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="250" y="135" text-anchor="middle" fill="white" font-weight="bold">Priority 3: Normal (1, 2, 4, 6)</text>
                            
                            <rect x="50" y="150" width="400" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="250" y="175" text-anchor="middle" fill="white" font-weight="bold">Priority 4: Low (8, 9)</text>
                        </g>
                        
                        <!-- Arrow markers -->
                        <defs>
                            <marker id="arrowhead-green" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#27ae60"/>
                            </marker>
                            <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>
                    </svg>
                    <div class="svg-caption">Figure 4: Types of Queues - Simple, Circular, and Priority</div>
                </div>
                
                <p><strong>Queue Types:</strong></p>
                <ul>
                    <li><strong>Simple Queue:</strong> Basic FIFO structure</li>
                    <li><strong>Circular Queue:</strong> Connects rear to front to utilize empty space</li>
                    <li><strong>Priority Queue:</strong> Elements served based on priority, not arrival order</li>
                    <li><strong>Double-Ended Queue (Deque):</strong> Can add/remove from both ends</li>
                </ul>
                
                <p><strong>Queue Operations:</strong></p>
                <ul>
                    <li><strong>Enqueue:</strong> Add element to rear - O(1)</li>
                    <li><strong>Dequeue:</strong> Remove element from front - O(1)</li>
                    <li><strong>Front:</strong> View front element - O(1)</li>
                    <li><strong>Rear:</strong> View rear element - O(1)</li>
                    <li><strong>isEmpty:</strong> Check if queue is empty - O(1)</li>
                    <li><strong>isFull:</strong> Check if queue is full - O(1)</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Circular Queue Implementation</div>
                    <div class="code">
#define SIZE 5

typedef struct {
    int items[SIZE];
    int front, rear;
} CircularQueue;

void init(CircularQueue *q) {
    q->front = -1;
    q->rear = -1;
}

int enqueue(CircularQueue *q, int item) {
    if ((q->front == 0 && q->rear == SIZE - 1) || 
        (q->rear == (q->front - 1) % (SIZE - 1))) {
        return 0; // Queue full
    }
    
    if (q->front == -1) {
        q->front = q->rear = 0;
    } else if (q->rear == SIZE - 1 && q->front != 0) {
        q->rear = 0;
    } else {
        q->rear++;
    }
    
    q->items[q->rear] = item;
    return 1;
}

int dequeue(CircularQueue *q, int *item) {
    if (q->front == -1) {
        return 0; // Queue empty
    }
    
    *item = q->items[q->front];
    
    if (q->front == q->rear) {
        q->front = q->rear = -1;
    } else if (q->front == SIZE - 1) {
        q->front = 0;
    } else {
        q->front++;
    }
    
    return 1;
}
                    </div>
                </div>
                
                <p><strong>Applications of Queues:</strong></p>
                <ul>
                    <li><strong>Operating Systems:</strong> Process scheduling, job queues</li>
                    <li><strong>Network Protocols:</strong> Packet routing, buffer management</li>
                    <li><strong>Print Spooling:</strong> Managing print jobs</li>
                    <li><strong>Breadth-First Search:</strong> Graph traversal algorithm</li>
                    <li><strong>Customer Service:</strong> Call center systems, ticket counters</li>
                </ul>
                
                <div class="formula">
                    Circular Queue Full Condition: (rear + 1) % size == front
                    <br>
                    Time Complexity: All operations = O(1)
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">5. Linked Lists: Singly, Doubly, and Circular</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üîó For a 5-Year-Old: What are Linked Lists?</div>
                <p>Imagine a treasure hunt where each clue tells you where to find the next clue! You start with the first clue, and it leads you to the second, which leads to the third, and so on. Linked lists are like this - each piece of data knows where to find the next piece of data!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîó Formal Definition & Types</div>
                <p><strong>Linked Lists</strong> are linear data structures where elements are not stored at contiguous memory locations. Each element (node) contains data and a pointer to the next node.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- Singly Linked List -->
                        <g transform="translate(50, 50)">
                            <text x="250" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Singly Linked List</text>
                            
                            <!-- Head pointer -->
                            <circle cx="30" cy="40" r="8" fill="#e74c3c"/>
                            <text x="30" y="45" text-anchor="middle" fill="white" font-size="10" font-weight="bold">H</text>
                            <path d="M 38 40 L 60 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 1 -->
                            <rect x="60" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="80" y="45" text-anchor="middle" fill="white" font-size="12">10</text>
                            
                            <rect x="100" y="25" width="40" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <path d="M 140 40 L 170 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 2 -->
                            <rect x="170" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="190" y="45" text-anchor="middle" fill="white" font-size="12">20</text>
                            
                            <rect x="210" y="25" width="40" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <path d="M 250 40 L 280 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 3 -->
                            <rect x="280" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="300" y="45" text-anchor="middle" fill="white" font-size="12">30</text>
                            
                            <rect x="320" y="25" width="40" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <text x="340" y="45" text-anchor="middle" fill="#7f8c8d" font-size="10">NULL</text>
                            
                            <!-- Labels -->
                            <text x="80" y="70" text-anchor="middle" font-size="10" fill="#7f8c8d">Data</text>
                            <text x="120" y="70" text-anchor="middle" font-size="10" fill="#7f8c8d">Next</text>
                        </g>
                        
                        <!-- Doubly Linked List -->
                        <g transform="translate(50, 150)">
                            <text x="250" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Doubly Linked List</text>
                            
                            <!-- Head pointer -->
                            <circle cx="30" cy="40" r="8" fill="#e74c3c"/>
                            <text x="30" y="45" text-anchor="middle" fill="white" font-size="10" font-weight="bold">H</text>
                            <path d="M 38 40 L 60 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 1 -->
                            <rect x="60" y="25" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <text x="75" y="45" text-anchor="middle" fill="#7f8c8d" font-size="10">NULL</text>
                            
                            <rect x="90" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="110" y="45" text-anchor="middle" fill="white" font-size="12">10</text>
                            
                            <rect x="130" y="25" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <path d="M 160 40 L 180 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 2 -->
                            <rect x="180" y="25" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <path d="M 180 40 L 160 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <rect x="210" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="230" y="45" text-anchor="middle" fill="white" font-size="12">20</text>
                            
                            <rect x="250" y="25" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <path d="M 280 40 L 300 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 3 -->
                            <rect x="300" y="25" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <path d="M 300 40 L 280 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <rect x="330" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="350" y="45" text-anchor="middle" fill="white" font-size="12">30</text>
                            
                            <rect x="370" y="25" width="30" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <text x="385" y="45" text-anchor="middle" fill="#7f8c8d" font-size="10">NULL</text>
                            
                            <!-- Labels -->
                            <text x="75" y="70" text-anchor="middle" font-size="10" fill="#7f8c8d">Prev</text>
                            <text x="110" y="70" text-anchor="middle" font-size="10" fill="#7f8c8d">Data</text>
                            <text x="145" y="70" text-anchor="middle" font-size="10" fill="#7f8c8d">Next</text>
                        </g>
                        
                        <!-- Circular Linked List -->
                        <g transform="translate(50, 280)">
                            <text x="250" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Circular Linked List</text>
                            
                            <!-- Head pointer -->
                            <circle cx="30" cy="40" r="8" fill="#e74c3c"/>
                            <text x="30" y="45" text-anchor="middle" fill="white" font-size="10" font-weight="bold">H</text>
                            <path d="M 38 40 L 60 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 1 -->
                            <rect x="60" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="80" y="45" text-anchor="middle" fill="white" font-size="12">10</text>
                            
                            <rect x="100" y="25" width="40" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <path d="M 140 40 L 170 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 2 -->
                            <rect x="170" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="190" y="45" text-anchor="middle" fill="white" font-size="12">20</text>
                            
                            <rect x="210" y="25" width="40" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            <path d="M 250 40 L 280 40" stroke="#2c3e50" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                            
                            <!-- Node 3 -->
                            <rect x="280" y="25" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="300" y="45" text-anchor="middle" fill="white" font-size="12">30</text>
                            
                            <rect x="320" y="25" width="40" height="30" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2"/>
                            
                            <!-- Circular connection -->
                            <path d="M 340 25 Q 400 10, 400 40 Q 400 70, 340 55" stroke="#e74c3c" stroke-width="2" fill="none" marker-end="url(#arrowhead-red)"/>
                            <path d="M 360 40 L 60 40" stroke="#e74c3c" stroke-width="2" fill="none" stroke-dasharray="5,5"/>
                            
                            <!-- Labels -->
                            <text x="80" y="70" text-anchor="middle" font-size="10" fill="#7f8c8d">Data</text>
                            <text x="120" y="70" text-anchor="middle" font-size="10" fill="#7f8c8d">Next</text>
                        </g>
                        
                        <!-- Comparison Table -->
                        <g transform="translate(50, 380)">
                            <text x="250" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Linked List Types Comparison</text>
                            
                            <!-- Table header -->
                            <rect x="0" y="20" width="120" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="60" y="40" text-anchor="middle" fill="white" font-weight="bold">Type</text>
                            
                            <rect x="120" y="20" width="150" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="195" y="40" text-anchor="middle" fill="white" font-weight="bold">Memory/Node</text>
                            
                            <rect x="270" y="20" width="130" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="335" y="40" text-anchor="middle" fill="white" font-weight="bold">Traversal</text>
                            
                            <rect x="400" y="20" width="120" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="460" y="40" text-anchor="middle" fill="white" font-weight="bold">Operations</text>
                            
                            <!-- Singly -->
                            <rect x="0" y="50" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="60" y="67" text-anchor="middle">Singly</text>
                            
                            <rect x="120" y="50" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="195" y="67" text-anchor="middle">Data + Next</text>
                            
                            <rect x="270" y="50" width="130" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="335" y="67" text-anchor="middle">Forward only</text>
                            
                            <rect x="400" y="50" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="460" y="67" text-anchor="middle">O(1) insert head</text>
                            
                            <!-- Doubly -->
                            <rect x="0" y="75" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="60" y="92" text-anchor="middle">Doubly</text>
                            
                            <rect x="120" y="75" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="195" y="92" text-anchor="middle">Prev + Data + Next</text>
                            
                            <rect x="270" y="75" width="130" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="335" y="92" text-anchor="middle">Both directions</text>
                            
                            <rect x="400" y="75" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="460" y="92" text-anchor="middle">O(1) delete tail</text>
                            
                            <!-- Circular -->
                            <rect x="0" y="100" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="60" y="117" text-anchor="middle">Circular</text>
                            
                            <rect x="120" y="100" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="195" y="117" text-anchor="middle">Data + Next (circular)</text>
                            
                            <rect x="270" y="100" width="130" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="335" y="117" text-anchor="middle">Infinite loop</text>
                            
                            <rect x="400" y="100" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="460" y="117" text-anchor="middle">No NULL checks</text>
                        </g>
                        
                        <!-- Arrow markers -->
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                            </marker>
                            <marker id="arrowhead-red" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#e74c3c"/>
                            </marker>
                        </defs>
                    </svg>
                    <div class="svg-caption">Figure 5: Types of Linked Lists - Singly, Doubly, and Circular</div>
                </div>
                
                <p><strong>Linked List Operations:</strong></p>
                <ul>
                    <li><strong>Insertion:</strong> At beginning, end, or specific position</li>
                    <li><strong>Deletion:</strong> From beginning, end, or specific position</li>
                    <li><strong>Traversal:</strong> Visit all nodes in the list</li>
                    <li><strong>Search:</strong> Find a specific value</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Singly Linked List Node Structure and Operations</div>
                    <div class="code">
// Node structure
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Insert at beginning
Node* insertAtBeginning(Node* head, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = head;
    return newNode;
}

// Insert at end
Node* insertAtEnd(Node* head, int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = data;
    newNode->next = NULL;
    
    if (head == NULL) {
        return newNode;
    }
    
    Node* current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
    return head;
}

// Delete from beginning
Node* deleteFromBeginning(Node* head) {
    if (head == NULL) {
        return NULL;
    }
    Node* temp = head;
    head = head->next;
    free(temp);
    return head;
}
                    </div>
                </div>
                
                <p><strong>Advantages over Arrays:</strong></p>
                <ul>
                    <li><strong>Dynamic Size:</strong> Can grow and shrink as needed</li>
                    <li><strong>Efficient Insertion/Deletion:</strong> O(1) at beginning/end (no shifting)</li>
                    <li><strong>Memory Utilization:</strong> No wasted space for unused capacity</li>
                </ul>
                
                <p><strong>Disadvantages:</strong></p>
                <ul>
                    <li><strong>No Random Access:</strong> Must traverse sequentially</li>
                    <li><strong>Extra Memory:</strong> Additional space for pointers</li>
                    <li><strong>Cache Unfriendly:</strong> Non-contiguous memory</li>
                </ul>
                
                <div class="formula">
                    Time Complexity:
                    <br>
                    ‚Ä¢ Access: O(n)
                    <br>
                    ‚Ä¢ Search: O(n)
                    <br>
                    ‚Ä¢ Insertion: O(1) at beginning/end, O(n) at position
                    <br>
                    ‚Ä¢ Deletion: O(1) at beginning/end, O(n) at position
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">Module Summary & Exam Focus</h2>
        
        <div class="concept">
            <div class="deep-explanation">
                <div class="deep-title">üéØ Key Exam Topics from Module 2</div>
                
                <p><strong>High-Frequency Exam Questions:</strong></p>
                <ol>
                    <li><strong>Array Operations and Complexity Analysis:</strong>
                        <ul>
                            <li>Calculate time complexity of array operations</li>
                            <li>Compare array vs linked list performance</li>
                            <li>Multi-dimensional array operations</li>
                        </ul>
                    </li>
                    
                    <li><strong>Sparse Matrix Representation:</strong>
                        <ul>
                            <li>Convert between different sparse matrix representations</li>
                            <li>Calculate memory efficiency</li>
                            <li>Implement sparse matrix operations</li>
                        </ul>
                    </li>
                    
                    <li><strong>Stack and Queue Implementations:</strong>
                        <ul>
                            <li>Array-based vs linked list-based implementations</li>
                            <li>Circular queue operations and overflow/underflow handling</li>
                            <li>Applications in expression evaluation and scheduling</li>
                        </ul>
                    </li>
                    
                    <li><strong>Linked List Operations:</strong>
                        <ul>
                            <li>Insertion and deletion in all three types</li>
                            <li>Traversal and searching algorithms</li>
                            <li>Comparison between different linked list types</li>
                        </ul>
                    </li>
                    
                    <li><strong>Practical Applications:</strong>
                        <ul>
                            <li>Stack applications: expression evaluation, function calls</li>
                            <li>Queue applications: BFS, scheduling</li>
                            <li>Linked list applications: polynomial representation</li>
                        </ul>
                    </li>
                </ol>
                
                <div class="example">
                    <div class="example-title">üìù Sample Exam Question</div>
                    <p><strong>Question:</strong> Implement a circular queue using array and write algorithms for enqueue and dequeue operations. Handle the conditions for queue full and queue empty.</p>
                    <p><strong>Solution Approach:</strong>
                    <br>1. Define queue structure with array, front, rear pointers
                    <br>2. Implement enqueue with circular condition: (rear + 1) % size != front
                    <br>3. Implement dequeue with circular condition: front != -1
                    <br>4. Handle special cases: empty queue, single element, full queue
                    <br>5. Update front and rear pointers using modulo arithmetic</p>
                </div>
                
                <p><strong>Study Strategy:</strong></p>
                <ul>
                    <li>Master the implementation details of all data structures</li>
                    <li>Understand the trade-offs between different implementations</li>
                    <li>Practice complexity analysis for all operations</li>
                    <li>Focus on edge cases and error handling</li>
                    <li>Work through previous year question papers</li>
                </ul>
                
                <div class="formula">
                    Exam Success = Implementation Skills + Complexity Analysis + Application Knowledge
                </div>
            </div>
        </div>
    </div>
    <div class="header">
        <h2 class="subtitle">Module 3: Trees</h2>
    </div>

    <div class="section">
        <h2 class="section-title">1. Basic Tree Terminology</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üå≥ For a 5-Year-Old: What are Trees?</div>
                <p>Imagine a big tree in your backyard! It has one thick trunk at the bottom, then branches that split into smaller branches, and finally leaves at the ends. In computers, a tree is just like this - it starts with one "root" and branches out into smaller parts, ending with "leaves" that hold the information!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîç Formal Definition & Technical Terminology</div>
                <p><strong>Tree</strong> is a hierarchical data structure with a root value and subtrees of children with a parent-child relationship. It's an acyclic graph with exactly one path between any two nodes.</p>
                
                <div class="svg-container">
                    <svg width="700" height="400" viewBox="0 0 700 400" xmlns="http://www.w3.org/2000/svg">
                        <!-- Tree structure with labeled parts -->
                        <g transform="translate(350, 50)">
                            <text x="0" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Tree Terminology Visualization</text>
                            
                            <!-- Root node -->
                            <circle cx="0" cy="40" r="20" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="0" y="45" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            <text x="0" y="70" text-anchor="middle" font-size="12" fill="#e74c3c" font-weight="bold">ROOT</text>
                            
                            <!-- Level 1 nodes -->
                            <circle cx="-120" cy="120" r="18" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-120" y="125" text-anchor="middle" fill="white" font-weight="bold">B</text>
                            
                            <circle cx="0" cy="120" r="18" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="0" y="125" text-anchor="middle" fill="white" font-weight="bold">C</text>
                            
                            <circle cx="120" cy="120" r="18" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="120" y="125" text-anchor="middle" fill="white" font-weight="bold">D</text>
                            
                            <!-- Level 2 nodes -->
                            <circle cx="-180" cy="200" r="16" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-180" y="205" text-anchor="middle" fill="white" font-weight="bold">E</text>
                            
                            <circle cx="-60" cy="200" r="16" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-60" y="205" text-anchor="middle" fill="white" font-weight="bold">F</text>
                            
                            <circle cx="60" cy="200" r="16" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="60" y="205" text-anchor="middle" fill="white" font-weight="bold">G</text>
                            
                            <circle cx="180" cy="200" r="16" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="180" y="205" text-anchor="middle" fill="white" font-weight="bold">H</text>
                            
                            <!-- Level 3 nodes (leaves) -->
                            <circle cx="-210" cy="280" r="14" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-210" y="285" text-anchor="middle" fill="white" font-size="12">I</text>
                            <text x="-210" y="305" text-anchor="middle" font-size="10" fill="#f39c12">LEAF</text>
                            
                            <circle cx="-150" cy="280" r="14" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-150" y="285" text-anchor="middle" fill="white" font-size="12">J</text>
                            <text x="-150" y="305" text-anchor="middle" font-size="10" fill="#f39c12">LEAF</text>
                            
                            <circle cx="180" cy="280" r="14" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="180" y="285" text-anchor="middle" fill="white" font-size="12">K</text>
                            <text x="180" y="305" text-anchor="middle" font-size="10" fill="#f39c12">LEAF</text>
                            
                            <!-- Edges -->
                            <line x1="0" y1="60" x2="-120" y2="102" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="0" y1="60" x2="0" y2="102" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="0" y1="60" x2="120" y2="102" stroke="#2c3e50" stroke-width="2"/>
                            
                            <line x1="-120" y1="138" x2="-180" y2="184" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-120" y1="138" x2="-60" y2="184" stroke="#2c3e50" stroke-width="2"/>
                            
                            <line x1="0" y1="138" x2="60" y2="184" stroke="#2c3e50" stroke-width="2"/>
                            
                            <line x1="120" y1="138" x2="180" y2="184" stroke="#2c3e50" stroke-width="2"/>
                            
                            <line x1="-180" y1="216" x2="-210" y2="266" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-180" y1="216" x2="-150" y2="266" stroke="#2c3e50" stroke-width="2"/>
                            
                            <line x1="180" y1="216" x2="180" y2="266" stroke="#2c3e50" stroke-width="2"/>
                            
                            <!-- Annotations -->
                            <text x="-240" y="240" font-size="10" fill="#7f8c8d">Parent-Child</text>
                            <text x="-240" y="255" font-size="10" fill="#7f3e50">Relationship</text>
                            
                            <text x="90" y="160" font-size="10" fill="#7f8c8d">Siblings:</text>
                            <text x="90" y="175" font-size="10" fill="#7f8c8d">B, C, D</text>
                            
                            <text x="-300" y="120" font-size="10" fill="#7f8c8d">Subtree</text>
                            <text x="-300" y="135" font-size="10" fill="#7f8c8d">rooted at B</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 1: Tree Structure with Key Terminology</div>
                </div>
                
                <p><strong>Essential Tree Terminology:</strong></p>
                <ul>
                    <li><strong>Node:</strong> Basic unit of a tree containing data and links to other nodes</li>
                    <li><strong>Root:</strong> The topmost node with no parent</li>
                    <li><strong>Parent:</strong> A node that has child nodes</li>
                    <li><strong>Child:</strong> A node that has a parent node</li>
                    <li><strong>Siblings:</strong> Nodes with the same parent</li>
                    <li><strong>Leaf:</strong> A node with no children</li>
                    <li><strong>Internal Node:</strong> A node with at least one child</li>
                    <li><strong>Edge:</strong> Connection between parent and child</li>
                    <li><strong>Path:</strong> Sequence of nodes and edges connecting two nodes</li>
                    <li><strong>Height:</strong> Number of edges on longest path from node to leaf</li>
                    <li><strong>Depth:</strong> Number of edges from root to node</li>
                    <li><strong>Level:</strong> Depth + 1</li>
                    <li><strong>Subtree:</strong> Tree consisting of a node and all its descendants</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üìä Tree Properties Calculation</div>
                    <p>For the tree shown in Figure 1:</p>
                    <ul>
                        <li><strong>Height of tree:</strong> 3 (longest path: A‚ÜíB‚ÜíE‚ÜíI)</li>
                        <li><strong>Depth of node G:</strong> 2 (A‚ÜíC‚ÜíG)</li>
                        <li><strong>Level of node D:</strong> 2</li>
                        <li><strong>Number of leaves:</strong> 3 (I, J, K)</li>
                        <li><strong>Number of internal nodes:</strong> 8 (A, B, C, D, E, F, G, H)</li>
                        <li><strong>Degree of node B:</strong> 2 (has 2 children: E, F)</li>
                    </ul>
                </div>
                
                <div class="formula">
                    Height(T) = max(Height(child‚ÇÅ), Height(child‚ÇÇ), ..., Height(child‚Çô)) + 1
                    <br>
                    Depth(node) = Depth(parent) + 1
                    <br>
                    Level(node) = Depth(node) + 1
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">2. Binary Trees: Properties and Representation</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üåø For a 5-Year-Old: What are Binary Trees?</div>
                <p>Imagine a special tree where every branch can only split into exactly two smaller branches - no more, no less! A binary tree is like this - every spot on the tree can have at most two "children": one on the left and one on the right, just like your two hands!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üî¢ Formal Definition & Mathematical Properties</div>
                <p><strong>Binary Tree</strong> is a tree data structure where each node has at most two children, referred to as the left child and right child.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- Binary Tree Types -->
                        <g transform="translate(50, 50)">
                            <text x="300" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Types of Binary Trees</text>
                            
                            <!-- Complete Binary Tree -->
                            <g transform="translate(0, 30)">
                                <text x="150" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#2c3e50">Complete Binary Tree</text>
                                
                                <circle cx="150" cy="40" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="150" y="45" text-anchor="middle" fill="white" font-size="12">1</text>
                                
                                <circle cx="100" cy="90" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="100" y="95" text-anchor="middle" fill="white" font-size="12">2</text>
                                
                                <circle cx="200" cy="90" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="200" y="95" text-anchor="middle" fill="white" font-size="12">3</text>
                                
                                <circle cx="75" cy="140" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="75" y="145" text-anchor="middle" fill="white" font-size="12">4</text>
                                
                                <circle cx="125" cy="140" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="125" y="145" text-anchor="middle" fill="white" font-size="12">5</text>
                                
                                <circle cx="175" cy="140" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                                <text x="175" y="145" text-anchor="middle" fill="white" font-size="12">6</text>
                                
                                <circle cx="225" cy="140" r="15" fill="#ecf0f1" stroke="#2c3e50" stroke-width="2" stroke-dasharray="3,3"/>
                                <text x="225" y="145" text-anchor="middle" fill="#7f8c8d" font-size="12">7</text>
                                
                                <!-- Edges -->
                                <line x1="150" y1="55" x2="100" y2="75" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="150" y1="55" x2="200" y2="75" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="100" y1="105" x2="75" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="100" y1="105" x2="125" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="200" y1="105" x2="175" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="200" y1="105" x2="225" y2="125" stroke="#2c3e50" stroke-width="2" stroke-dasharray="3,3"/>
                            </g>
                            
                            <!-- Full Binary Tree -->
                            <g transform="translate(350, 30)">
                                <text x="150" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#2c3e50">Full Binary Tree</text>
                                
                                <circle cx="150" cy="40" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="150" y="45" text-anchor="middle" fill="white" font-size="12">1</text>
                                
                                <circle cx="100" cy="90" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="100" y="95" text-anchor="middle" fill="white" font-size="12">2</text>
                                
                                <circle cx="200" cy="90" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="200" y="95" text-anchor="middle" fill="white" font-size="12">3</text>
                                
                                <circle cx="75" cy="140" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="75" y="145" text-anchor="middle" fill="white" font-size="12">4</text>
                                
                                <circle cx="125" cy="140" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="125" y="145" text-anchor="middle" fill="white" font-size="12">5</text>
                                
                                <circle cx="175" cy="140" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="175" y="145" text-anchor="middle" fill="white" font-size="12">6</text>
                                
                                <circle cx="225" cy="140" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                                <text x="225" y="145" text-anchor="middle" fill="white" font-size="12">7</text>
                                
                                <!-- Edges -->
                                <line x1="150" y1="55" x2="100" y2="75" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="150" y1="55" x2="200" y2="75" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="100" y1="105" x2="75" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="100" y1="105" x2="125" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="200" y1="105" x2="175" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="200" y1="105" x2="225" y2="125" stroke="#2c3e50" stroke-width="2"/>
                            </g>
                            
                            <!-- Perfect Binary Tree -->
                            <g transform="translate(0, 230)">
                                <text x="150" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#2c3e50">Perfect Binary Tree</text>
                                
                                <circle cx="150" cy="40" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                                <text x="150" y="45" text-anchor="middle" fill="white" font-size="12">1</text>
                                
                                <circle cx="100" cy="90" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                                <text x="100" y="95" text-anchor="middle" fill="white" font-size="12">2</text>
                                
                                <circle cx="200" cy="90" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                                <text x="200" y="95" text-anchor="middle" fill="white" font-size="12">3</text>
                                
                                <circle cx="75" cy="140" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                                <text x="75" y="145" text-anchor="middle" fill="white" font-size="12">4</text>
                                
                                <circle cx="125" cy="140" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                                <text x="125" y="145" text-anchor="middle" fill="white" font-size="12">5</text>
                                
                                <circle cx="175" cy="140" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                                <text x="175" y="145" text-anchor="middle" fill="white" font-size="12">6</text>
                                
                                <circle cx="225" cy="140" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                                <text x="225" y="145" text-anchor="middle" fill="white" font-size="12">7</text>
                                
                                <!-- Edges -->
                                <line x1="150" y1="55" x2="100" y2="75" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="150" y1="55" x2="200" y2="75" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="100" y1="105" x2="75" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="100" y1="105" x2="125" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="200" y1="105" x2="175" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="200" y1="105" x2="225" y2="125" stroke="#2c3e50" stroke-width="2"/>
                            </g>
                            
                            <!-- Balanced Binary Tree -->
                            <g transform="translate(350, 230)">
                                <text x="150" y="0" text-anchor="middle" font-size="14" font-weight="bold" fill="#2c3e50">Balanced Binary Tree</text>
                                
                                <circle cx="150" cy="40" r="15" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                                <text x="150" y="45" text-anchor="middle" fill="white" font-size="12">8</text>
                                
                                <circle cx="100" cy="90" r="15" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                                <text x="100" y="95" text-anchor="middle" fill="white" font-size="12">3</text>
                                
                                <circle cx="200" cy="90" r="15" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                                <text x="200" y="95" text-anchor="middle" fill="white" font-size="12">10</text>
                                
                                <circle cx="75" cy="140" r="15" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                                <text x="75" y="145" text-anchor="middle" fill="white" font-size="12">1</text>
                                
                                <circle cx="125" cy="140" r="15" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                                <text x="125" y="145" text-anchor="middle" fill="white" font-size="12">6</text>
                                
                                <circle cx="175" cy="140" r="15" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                                <text x="175" y="145" text-anchor="middle" fill="white" font-size="12">14</text>
                                
                                <circle cx="225" cy="140" r="15" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                                <text x="225" y="145" text-anchor="middle" fill="white" font-size="12">18</text>
                                
                                <!-- Edges -->
                                <line x1="150" y1="55" x2="100" y2="75" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="150" y1="55" x2="200" y2="75" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="100" y1="105" x2="75" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="100" y1="105" x2="125" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="200" y1="105" x2="175" y2="125" stroke="#2c3e50" stroke-width="2"/>
                                <line x1="200" y1="105" x2="225" y2="125" stroke="#2c3e50" stroke-width="2"/>
                            </g>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 2: Types of Binary Trees</div>
                </div>
                
                <p><strong>Types of Binary Trees:</strong></p>
                <ul>
                    <li><strong>Full Binary Tree:</strong> Every node has 0 or 2 children</li>
                    <li><strong>Complete Binary Tree:</strong> All levels except possibly the last are completely filled, and all nodes are as far left as possible</li>
                    <li><strong>Perfect Binary Tree:</strong> All interior nodes have two children and all leaves are at the same level</li>
                    <li><strong>Balanced Binary Tree:</strong> Height difference between left and right subtrees is at most 1 for all nodes</li>
                    <li><strong>Skewed Binary Tree:</strong> All nodes have only one child (left or right)</li>
                </ul>
                
                <p><strong>Mathematical Properties:</strong></p>
                <ul>
                    <li><strong>Maximum nodes at level i:</strong> 2^(i-1)</li>
                    <li><strong>Maximum nodes in tree of height h:</strong> 2^h - 1</li>
                    <li><strong>Minimum height for n nodes:</strong> ‚åàlog‚ÇÇ(n+1)‚åâ</li>
                    <li><strong>Maximum height for n nodes:</strong> n (for skewed tree)</li>
                    <li><strong>Number of leaf nodes:</strong> (n + 1) / 2 for full binary tree</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Binary Tree Node Structure</div>
                    <div class="code">
// Binary Tree Node Structure
typedef struct Node {
    int data;
    struct Node* left;
    struct Node* right;
} Node;

// Create a new node
Node* createNode(int data) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        return NULL;
    }
    newNode->data = data;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// Array representation of binary tree
// For a complete binary tree:
// Parent of node i: (i-1)/2
// Left child of node i: 2i + 1
// Right child of node i: 2i + 2

int treeArray[] = {1, 2, 3, 4, 5, 6, 7};
// Index 0: Root (1)
// Index 1: Left child of root (2)
// Index 2: Right child of root (3)
// Index 3: Left child of node 2 (4)
// Index 4: Right child of node 2 (5)
// Index 5: Left child of node 3 (6)
// Index 6: Right child of node 3 (7)
                    </div>
                </div>
                
                <div class="formula">
                    Maximum nodes at level i = 2^(i-1)
                    <br>
                    Maximum nodes in tree of height h = 2^h - 1
                    <br>
                    For array representation:
                    <br>
                    ‚Ä¢ Left child of node i: 2i + 1
                    <br>
                    ‚Ä¢ Right child of node i: 2i + 2
                    <br>
                    ‚Ä¢ Parent of node i: ‚åä(i-1)/2‚åã
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">3. Tree Traversal Algorithms</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üö∂‚Äç‚ôÇÔ∏è For a 5-Year-Old: What is Tree Traversal?</div>
                <p>Imagine you're exploring a treehouse! You can visit different parts in different ways. You could start at the top and go down one side first, or you could visit every level from top to bottom. Tree traversal is like choosing different paths to visit every part of the tree and collect all the information!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîÑ Formal Definition & Traversal Methods</div>
                <p><strong>Tree Traversal</strong> is the process of visiting each node in a tree data structure exactly once. Different traversal orders produce different sequences of node visits.</p>
                
                <div class="svg-container">
                    <svg width="700" height="600" viewBox="0 0 700 600" xmlns="http://www.w3.org/2000/svg">
                        <!-- Sample Tree for Traversal -->
                        <g transform="translate(350, 50)">
                            <text x="0" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Sample Binary Tree for Traversal</text>
                            
                            <!-- Tree structure -->
                            <circle cx="0" cy="50" r="20" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="0" y="55" text-anchor="middle" fill="white" font-weight="bold">F</text>
                            
                            <circle cx="-100" cy="120" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-100" y="125" text-anchor="middle" fill="white" font-weight="bold">B</text>
                            
                            <circle cx="100" cy="120" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="125" text-anchor="middle" fill="white" font-weight="bold">G</text>
                            
                            <circle cx="-150" cy="190" r="20" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-150" y="195" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            
                            <circle cx="-50" cy="190" r="20" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-50" y="195" text-anchor="middle" fill="white" font-weight="bold">D</text>
                            
                            <circle cx="150" cy="190" r="20" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="195" text-anchor="middle" fill="white" font-weight="bold">I</text>
                            
                            <circle cx="-75" cy="260" r="20" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-75" y="265" text-anchor="middle" fill="white" font-weight="bold">C</text>
                            
                            <circle cx="-25" cy="260" r="20" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-25" y="265" text-anchor="middle" fill="white" font-weight="bold">E</text>
                            
                            <circle cx="125" cy="260" r="20" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="125" y="265" text-anchor="middle" fill="white" font-weight="bold">H</text>
                            
                            <!-- Edges -->
                            <line x1="0" y1="70" x2="-100" y2="100" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="0" y1="70" x2="100" y2="100" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-100" y1="140" x2="-150" y2="170" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-100" y1="140" x2="-50" y2="170" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="100" y1="140" x2="150" y2="170" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-50" y1="210" x2="-75" y2="240" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-50" y1="210" x2="-25" y2="240" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="150" y1="210" x2="125" y2="240" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        
                        <!-- Traversal Results -->
                        <g transform="translate(50, 350)">
                            <text x="300" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Traversal Results</text>
                            
                            <!-- Inorder Traversal -->
                            <rect x="0" y="20" width="600" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="10" y="35" font-size="12" fill="white" font-weight="bold">Inorder (Left-Root-Right):</text>
                            <text x="10" y="50" font-size="14" fill="white">A, B, C, D, E, F, G, H, I</text>
                            
                            <!-- Preorder Traversal -->
                            <rect x="0" y="70" width="600" height="40" fill="#e74c3c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="10" y="85" font-size="12" fill="white" font-weight="bold">Preorder (Root-Left-Right):</text>
                            <text x="10" y="100" font-size="14" fill="white">F, B, A, D, C, E, G, I, H</text>
                            
                            <!-- Postorder Traversal -->
                            <rect x="0" y="120" width="600" height="40" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="10" y="135" font-size="12" fill="white" font-weight="bold">Postorder (Left-Right-Root):</text>
                            <text x="10" y="150" font-size="14" fill="white">A, C, E, D, B, H, I, G, F</text>
                            
                            <!-- Level Order Traversal -->
                            <rect x="0" y="170" width="600" height="40" fill="#f39c12" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="10" y="185" font-size="12" fill="white" font-weight="bold">Level Order (BFS):</text>
                            <text x="10" y="200" font-size="14" fill="white">F, B, G, A, D, I, C, E, H</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 3: Tree Traversal Methods and Results</div>
                </div>
                
                <p><strong>Depth-First Traversal (DFS):</strong></p>
                <ul>
                    <li><strong>Inorder (Left-Root-Right):</strong> Visit left subtree, root, then right subtree</li>
                    <li><strong>Preorder (Root-Left-Right):</strong> Visit root, left subtree, then right subtree</li>
                    <li><strong>Postorder (Left-Right-Root):</strong> Visit left subtree, right subtree, then root</li>
                </ul>
                
                <p><strong>Breadth-First Traversal (BFS):</strong></p>
                <ul>
                    <li><strong>Level Order:</strong> Visit nodes level by level from top to bottom</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Tree Traversal Implementation</div>
                    <div class="code">
// Inorder Traversal (Left-Root-Right)
void inorder(Node* root) {
    if (root == NULL) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

// Preorder Traversal (Root-Left-Right)
void preorder(Node* root) {
    if (root == NULL) return;
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}

// Postorder Traversal (Left-Right-Root)
void postorder(Node* root) {
    if (root == NULL) return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}

// Level Order Traversal (using queue)
#include <stdlib.h>
#define MAX_SIZE 100

typedef struct {
    Node* array[MAX_SIZE];
    int front, rear;
} Queue;

void levelOrder(Node* root) {
    if (root == NULL) return;
    
    Queue q;
    q.front = q.rear = -1;
    q.array[++q.rear] = root;
    
    while (q.front <= q.rear) {
        Node* current = q.array[q.front++];
        printf("%d ", current->data);
        
        if (current->left != NULL)
            q.array[++q.rear] = current->left;
        if (current->right != NULL)
            q.array[++q.rear] = current->right;
    }
}
                    </div>
                </div>
                
                <p><strong>Time and Space Complexity:</strong></p>
                <ul>
                    <li><strong>Time Complexity:</strong> O(n) for all traversal methods (visits each node exactly once)</li>
                    <li><strong>Space Complexity:</strong>
                        <ul>
                            <li>DFS (Recursive): O(h) where h is height of tree (call stack)</li>
                            <li>Level Order: O(w) where w is maximum width of tree (queue size)</li>
                        </ul>
                    </li>
                </ul>
                
                <div class="formula">
                    Time Complexity: T(n) = O(n) for all traversals
                    <br>
                    Space Complexity:
                    <br>
                    ‚Ä¢ DFS (Recursive): S(n) = O(h) where h = tree height
                    <br>
                    ‚Ä¢ Level Order: S(n) = O(w) where w = maximum width
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">4. Binary Search Trees (BST)</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üîç For a 5-Year-Old: What is a Binary Search Tree?</div>
                <p>Imagine a special bookshelf where books are arranged in a very smart way! Books with smaller numbers go on the left side, and books with bigger numbers go on the right side. This makes it super easy to find any book quickly - you just go left or right depending on whether you're looking for a smaller or bigger number!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üéØ Formal Definition & BST Properties</div>
                <p><strong>Binary Search Tree (BST)</strong> is a binary tree where for each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater than the node.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- BST Example -->
                        <g transform="translate(350, 50)">
                            <text x="0" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Binary Search Tree Example</text>
                            
                            <!-- BST structure -->
                            <circle cx="0" cy="50" r="20" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="0" y="55" text-anchor="middle" fill="white" font-weight="bold">50</text>
                            
                            <circle cx="-120" cy="120" r="18" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-120" y="125" text-anchor="middle" fill="white" font-weight="bold">30</text>
                            
                            <circle cx="120" cy="120" r="18" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="120" y="125" text-anchor="middle" fill="white" font-weight="bold">70</text>
                            
                            <circle cx="-180" cy="190" r="16" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-180" y="195" text-anchor="middle" fill="white" font-weight="bold">20</text>
                            
                            <circle cx="-60" cy="190" r="16" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-60" y="195" text-anchor="middle" fill="white" font-weight="bold">40</text>
                            
                            <circle cx="60" cy="190" r="16" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="60" y="195" text-anchor="middle" fill="white" font-weight="bold">60</text>
                            
                            <circle cx="180" cy="190" r="16" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="180" y="195" text-anchor="middle" fill="white" font-weight="bold">80</text>
                            
                            <circle cx="-210" cy="260" r="14" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-210" y="265" text-anchor="middle" fill="white" font-size="12">10</text>
                            
                            <circle cx="-150" cy="260" r="14" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-150" y="265" text-anchor="middle" fill="white" font-size="12">25</text>
                            
                            <circle cx="-90" cy="260" r="14" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-90" y="265" text-anchor="middle" fill="white" font-size="12">35</text>
                            
                            <circle cx="-30" cy="260" r="14" fill="#f39c12" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-30" y="265" text-anchor="middle" fill="white" font-size="12">45</text>
                            
                            <!-- Edges -->
                            <line x1="0" y1="70" x2="-120" y2="102" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="0" y1="70" x2="120" y2="102" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-120" y1="138" x2="-180" y2="174" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-120" y1="138" x2="-60" y2="174" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="120" y1="138" x2="60" y2="174" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="120" y1="138" x2="180" y2="174" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-180" y1="206" x2="-210" y2="246" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-180" y1="206" x2="-150" y2="246" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-60" y1="206" x2="-90" y2="246" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-60" y1="206" x2="-30" y2="246" stroke="#2c3e50" stroke-width="2"/>
                            
                            <!-- BST Property annotations -->
                            <text x="-250" y="140" font-size="10" fill="#27ae60">Left < 30</text>
                            <text x="10" y="140" font-size="10" fill="#e74c3c">Right > 30</text>
                            
                            <text x="-250" y="210" font-size="10" fill="#27ae60">Left < 20</text>
                            <text x="-130" y="210" font-size="10" fill="#e74c3c">Right > 20</text>
                        </g>
                        
                        <!-- BST Operations -->
                        <g transform="translate(50, 340)">
                            <text x="300" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">BST Operations and Complexity</text>
                            
                            <!-- Operations table -->
                            <rect x="0" y="20" width="150" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="75" y="40" text-anchor="middle" fill="white" font-weight="bold">Operation</text>
                            
                            <rect x="150" y="20" width="200" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="250" y="40" text-anchor="middle" fill="white" font-weight="bold">Average Case</text>
                            
                            <rect x="350" y="20" width="150" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="425" y="40" text-anchor="middle" fill="white" font-weight="bold">Worst Case</text>
                            
                            <!-- Search -->
                            <rect x="0" y="50" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="75" y="67" text-anchor="middle">Search</text>
                            
                            <rect x="150" y="50" width="200" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="250" y="67" text-anchor="middle">O(log n)</text>
                            
                            <rect x="350" y="50" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="425" y="67" text-anchor="middle">O(n)</text>
                            
                            <!-- Insert -->
                            <rect x="0" y="75" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="75" y="92" text-anchor="middle">Insert</text>
                            
                            <rect x="150" y="75" width="200" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="250" y="92" text-anchor="middle">O(log n)</text>
                            
                            <rect x="350" y="75" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="425" y="92" text-anchor="middle">O(n)</text>
                            
                            <!-- Delete -->
                            <rect x="0" y="100" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="75" y="117" text-anchor="middle">Delete</text>
                            
                            <rect x="150" y="100" width="200" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="250" y="117" text-anchor="middle">O(log n)</text>
                            
                            <rect x="350" y="100" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="425" y="117" text-anchor="middle">O(n)</text>
                            
                            <!-- Traversal -->
                            <rect x="0" y="125" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="75" y="142" text-anchor="middle">Traversal</text>
                            
                            <rect x="150" y="125" width="200" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="250" y="142" text-anchor="middle">O(n)</text>
                            
                            <rect x="350" y="125" width="150" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="425" y="142" text-anchor="middle">O(n)</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 4: Binary Search Tree Structure and Operations</div>
                </div>
                
                <p><strong>BST Properties:</strong></p>
                <ul>
                    <li><strong>Left Subtree Property:</strong> All values in left subtree < root value</li>
                    <li><strong>Right Subtree Property:</strong> All values in right subtree > root value</li>
                    <li><strong>No Duplicates:</strong> Typically, BSTs don't contain duplicate values</li>
                    <li><strong>Inorder Traversal:</strong> Produces sorted sequence of values</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª BST Operations Implementation</div>
                    <div class="code">
// BST Node Structure
typedef struct BSTNode {
    int data;
    struct BSTNode* left;
    struct BSTNode* right;
} BSTNode;

// Search in BST
BSTNode* search(BSTNode* root, int key) {
    if (root == NULL || root->data == key) {
        return root;
    }
    
    if (key < root->data) {
        return search(root->left, key);
    } else {
        return search(root->right, key);
    }
}

// Insert in BST
BSTNode* insert(BSTNode* root, int data) {
    if (root == NULL) {
        BSTNode* newNode = (BSTNode*)malloc(sizeof(BSTNode));
        newNode->data = data;
        newNode->left = newNode->right = NULL;
        return newNode;
    }
    
    if (data < root->data) {
        root->left = insert(root->left, data);
    } else if (data > root->data) {
        root->right = insert(root->right, data);
    }
    
    return root;
}

// Find minimum value node
BSTNode* minValueNode(BSTNode* node) {
    BSTNode* current = node;
    while (current && current->left != NULL) {
        current = current->left;
    }
    return current;
}

// Delete from BST
BSTNode* delete(BSTNode* root, int key) {
    if (root == NULL) return root;
    
    if (key < root->data) {
        root->left = delete(root->left, key);
    } else if (key > root->data) {
        root->right = delete(root->right, key);
    } else {
        // Node with only one child or no child
        if (root->left == NULL) {
            BSTNode* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            BSTNode* temp = root->left;
            free(root);
            return temp;
        }
        
        // Node with two children
        BSTNode* temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = delete(root->right, temp->data);
    }
    
    return root;
}
                    </div>
                </div>
                
                <p><strong>Deletion Cases in BST:</strong></p>
                <ul>
                    <li><strong>Case 1: Node is a leaf</strong> - Simply remove the node</li>
                    <li><strong>Case 2: Node has one child</strong> - Replace node with its child</li>
                    <li><strong>Case 3: Node has two children</strong> - Find inorder successor (minimum in right subtree), copy its value, and delete the successor</li>
                </ul>
                
                <div class="formula">
                    BST Search Time Complexity:
                    <br>
                    ‚Ä¢ Average Case (balanced): O(log n)
                    <br>
                    ‚Ä¢ Worst Case (skewed): O(n)
                    <br>
                    ‚Ä¢ Space Complexity: O(h) for recursive operations
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">5. AVL Trees and B-Trees</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">‚öñÔ∏è For a 5-Year-Old: What are AVL and B-Trees?</div>
                <p>Imagine you're building a tower with blocks! AVL trees are like towers that you keep perfectly balanced - if one side gets too tall, you quickly adjust it to make both sides equal. B-Trees are like special folders that can hold many papers instead of just two, making them super organized and fast to search through!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üèóÔ∏è Formal Definition & Advanced Tree Structures</div>
                <p><strong>AVL Trees</strong> and <strong>B-Trees</strong> are self-balancing tree structures that maintain optimal performance for search, insert, and delete operations.</p>
                
                <div class="svg-container">
                    <svg width="700" height="600" viewBox="0 0 700 600" xmlns="http://www.w3.org/2000/svg">
                        <!-- AVL Tree Example -->
                        <g transform="translate(50, 50)">
                            <text x="150" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">AVL Tree (Balance Factor = |Height(L) - Height(R)| ‚â§ 1)</text>
                            
                            <!-- AVL Tree structure -->
                            <circle cx="150" cy="40" r="18" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="45" text-anchor="middle" fill="white" font-weight="bold">30</text>
                            <text x="150" y="65" text-anchor="middle" font-size="10" fill="#e74c3c">BF: 0</text>
                            
                            <circle cx="80" cy="100" r="16" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="80" y="105" text-anchor="middle" fill="white" font-weight="bold">20</text>
                            <text x="80" y="120" text-anchor="middle" font-size="9" fill="#3498db">BF: 0</text>
                            
                            <circle cx="220" cy="100" r="16" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="220" y="105" text-anchor="middle" fill="white" font-weight="bold">40</text>
                            <text x="220" y="120" text-anchor="middle" font-size="9" fill="#3498db">BF: 0</text>
                            
                            <circle cx="50" cy="160" r="14" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="165" text-anchor="middle" fill="white" font-size="12">10</text>
                            
                            <circle cx="110" cy="160" r="14" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="110" y="165" text-anchor="middle" fill="white" font-size="12">25</text>
                            
                            <circle cx="190" cy="160" r="14" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="190" y="165" text-anchor="middle" fill="white" font-size="12">35</text>
                            
                            <circle cx="250" cy="160" r="14" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="250" y="165" text-anchor="middle" fill="white" font-size="12">50</text>
                            
                            <!-- AVL edges -->
                            <line x1="150" y1="58" x2="80" y2="84" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="150" y1="58" x2="220" y2="84" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="80" y1="116" x2="50" y2="146" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="80" y1="116" x2="110" y2="146" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="220" y1="116" x2="190" y2="146" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="220" y1="116" x2="250" y2="146" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        
                        <!-- B-Tree Example -->
                        <g transform="translate(400, 50)">
                            <text x="150" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">B-Tree (Order 3: Max 2 keys, 3 children)</text>
                            
                            <!-- B-Tree root -->
                            <rect x="100" y="30" width="100" height="30" fill="#9b59b6" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="150" y="50" text-anchor="middle" fill="white" font-weight="bold">50 | 80</text>
                            
                            <!-- B-Tree level 1 -->
                            <rect x="30" y="90" width="60" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="60" y="110" text-anchor="middle" fill="white" font-weight="bold">20 | 30</text>
                            
                            <rect x="120" y="90" width="60" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="150" y="110" text-anchor="middle" fill="white" font-weight="bold">60</text>
                            
                            <rect x="210" y="90" width="60" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="240" y="110" text-anchor="middle" fill="white" font-weight="bold">90 | 100</text>
                            
                            <!-- B-Tree level 2 -->
                            <rect x="10" y="150" width="40" height="25" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="3"/>
                            <text x="30" y="167" text-anchor="middle" fill="white" font-size="11">10</text>
                            
                            <rect x="70" y="150" width="40" height="25" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="3"/>
                            <text x="90" y="167" text-anchor="middle" fill="white" font-size="11">25</text>
                            
                            <rect x="130" y="150" width="40" height="25" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="3"/>
                            <text x="150" y="167" text-anchor="middle" fill="white" font-size="11">55</text>
                            
                            <rect x="190" y="150" width="40" height="25" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="3"/>
                            <text x="210" y="167" text-anchor="middle" fill="white" font-size="11">85</text>
                            
                            <rect x="250" y="150" width="40" height="25" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="3"/>
                            <text x="270" y="167" text-anchor="middle" fill="white" font-size="11">95</text>
                            
                            <!-- B-Tree edges -->
                            <line x1="120" y1="60" x2="60" y2="90" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="150" y1="60" x2="150" y2="90" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="180" y1="60" x2="240" y2="90" stroke="#2c3e50" stroke-width="2"/>
                            
                            <line x1="45" y1="120" x2="30" y2="150" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="75" y1="120" x2="90" y2="150" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="150" y1="120" x2="150" y2="150" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="225" y1="120" x2="210" y2="150" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="255" y1="120" x2="270" y2="150" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        
                        <!-- Comparison Table -->
                        <g transform="translate(50, 280)">
                            <text x="300" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">AVL Tree vs B-Tree Comparison</text>
                            
                            <!-- Table header -->
                            <rect x="0" y="20" width="120" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="60" y="40" text-anchor="middle" fill="white" font-weight="bold">Property</text>
                            
                            <rect x="120" y="20" width="240" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="240" y="40" text-anchor="middle" fill="white" font-weight="bold">AVL Tree</text>
                            
                            <rect x="360" y="20" width="240" height="30" fill="#34495e" stroke="#2c3e50"/>
                            <text x="480" y="40" text-anchor="middle" fill="white" font-weight="bold">B-Tree</text>
                            
                            <!-- Balance Factor -->
                            <rect x="0" y="50" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="60" y="67" text-anchor="middle">Balance</text>
                            
                            <rect x="120" y="50" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="240" y="67" text-anchor="middle">|Height(L) - Height(R)| ‚â§ 1</text>
                            
                            <rect x="360" y="50" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="480" y="67" text-anchor="middle">All leaves at same level</text>
                            
                            <!-- Node Structure -->
                            <rect x="0" y="75" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="60" y="92" text-anchor="middle">Node Type</text>
                            
                            <rect x="120" y="75" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="240" y="92" text-anchor="middle">Binary (1 key, 2 children max)</text>
                            
                            <rect x="360" y="75" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="480" y="92" text-anchor="middle">Multi-way (m-1 keys, m children)</text>
                            
                            <!-- Operations -->
                            <rect x="0" y="100" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="60" y="117" text-anchor="middle">Operations</text>
                            
                            <rect x="120" y="100" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="240" y="117" text-anchor="middle">Rotations for balancing</text>
                            
                            <rect x="360" y="100" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="480" y="117" text-anchor="middle">Node splitting/merging</text>
                            
                            <!-- Performance -->
                            <rect x="0" y="125" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="60" y="142" text-anchor="middle">Performance</text>
                            
                            <rect x="120" y="125" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="240" y="142" text-anchor="middle">O(log n) guaranteed</text>
                            
                            <rect x="360" y="125" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="480" y="142" text-anchor="middle">O(log n) with large branching</text>
                            
                            <!-- Use Cases -->
                            <rect x="0" y="150" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="60" y="167" text-anchor="middle">Use Cases</text>
                            
                            <rect x="120" y="150" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="240" y="167" text-anchor="middle">In-memory databases</text>
                            
                            <rect x="360" y="150" width="240" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="480" y="167" text-anchor="middle">Disk-based systems, filesystems</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 5: AVL Tree and B-Tree Structures Comparison</div>
                </div>
                
                <p><strong>AVL Tree Properties:</strong></p>
                <ul>
                    <li><strong>Balance Factor:</strong> |Height(left subtree) - Height(right subtree)| ‚â§ 1</li>
                    <li><strong>Self-Balancing:</strong> Automatically maintains balance through rotations</li>
                    <li><strong>Rotations:</strong> Four types: Left, Right, Left-Right, Right-Left</li>
                    <li><strong>Height:</strong> O(log n) guaranteed for n nodes</li>
                </ul>
                
                <p><strong>B-Tree Properties:</strong></p>
                <ul>
                    <li><strong>Order m:</strong> Maximum number of children</li>
                    <li><strong>Node Capacity:</strong> m-1 keys maximum, ‚åàm/2‚åâ-1 keys minimum</li>
                    <li><strong>Leaf Level:</strong> All leaves at the same level</li>
                    <li><strong>Balanced:</strong> Automatically balanced through node splitting</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª AVL Tree Rotation Implementation</div>
                    <div class="code">
// AVL Node Structure
typedef struct AVLNode {
    int data;
    struct AVLNode* left;
    struct AVLNode* right;
    int height;
} AVLNode;

// Get height of node
int height(AVLNode* node) {
    if (node == NULL) return 0;
    return node->height;
}

// Get balance factor
int getBalance(AVLNode* node) {
    if (node == NULL) return 0;
    return height(node->left) - height(node->right);
}

// Right rotation
AVLNode* rightRotate(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;
    
    // Perform rotation
    x->right = y;
    y->left = T2;
    
    // Update heights
    y->height = 1 + max(height(y->left), height(y->right));
    x->height = 1 + max(height(x->left), height(x->right));
    
    return x;
}

// Left rotation
AVLNode* leftRotate(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* T2 = y->left;
    
    // Perform rotation
    y->left = x;
    x->right = T2;
    
    // Update heights
    x->height = 1 + max(height(x->left), height(x->right));
    y->height = 1 + max(height(y->left), height(y->right));
    
    return y;
}

// Insert in AVL tree
AVLNode* avlInsert(AVLNode* node, int data) {
    // Standard BST insertion
    if (node == NULL) {
        AVLNode* newNode = (AVLNode*)malloc(sizeof(AVLNode));
        newNode->data = data;
        newNode->left = newNode->right = NULL;
        newNode->height = 1;
        return newNode;
    }
    
    if (data < node->data) {
        node->left = avlInsert(node->left, data);
    } else if (data > node->data) {
        node->right = avlInsert(node->right, data);
    } else {
        return node; // Duplicate keys not allowed
    }
    
    // Update height
    node->height = 1 + max(height(node->left), height(node->right));
    
    // Get balance factor
    int balance = getBalance(node);
    
    // Balance the tree if needed
    
    // Left Left Case
    if (balance > 1 && data < node->left->data) {
        return rightRotate(node);
    }
    
    // Right Right Case
    if (balance < -1 && data > node->right->data) {
        return leftRotate(node);
    }
    
    // Left Right Case
    if (balance > 1 && data > node->left->data) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    
    // Right Left Case
    if (balance < -1 && data < node->right->data) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }
    
    return node;
}
                    </div>
                </div>
                
                <div class="formula">
                    AVL Tree Balance Factor: BF = Height(L) - Height(R)
                    <br>
                    Balanced Condition: |BF| ‚â§ 1
                    <br>
                    B-Tree Properties:
                    <br>
                    ‚Ä¢ Maximum keys per node: m-1
                    <br>
                    ‚Ä¢ Minimum keys per node: ‚åàm/2‚åâ-1 (except root)
                    <br>
                    ‚Ä¢ Time Complexity: O(log‚Çò n) for all operations
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">Module Summary & Exam Focus</h2>
        
        <div class="concept">
            <div class="deep-explanation">
                <div class="deep-title">üéØ Key Exam Topics from Module 3</div>
                
                <p><strong>High-Frequency Exam Questions:</strong></p>
                <ol>
                    <li><strong>Tree Properties and Terminology:</strong>
                        <ul>
                            <li>Calculate height, depth, level of nodes</li>
                            <li>Identify types of binary trees</li>
                            <li>Prove mathematical properties of trees</li>
                        </ul>
                    </li>
                    
                    <li><strong>Tree Traversal Algorithms:</strong>
                        <ul>
                            <li>Write algorithms for all traversal methods</li>
                            <li>Convert between different traversal sequences</li>
                            <li>Reconstruct trees from traversal sequences</li>
                        </ul>
                    </li>
                    
                    <li><strong>Binary Search Tree Operations:</strong>
                        <ul>
                            <li>Implement search, insert, delete operations</li>
                            <li>Handle all deletion cases (leaf, one child, two children)</li>
                            <li>Analyze time complexity for different tree shapes</li>
                        </ul>
                    </li>
                    
                    <li><strong>AVL Tree Balancing:</strong>
                        <ul>
                            <li>Calculate balance factors</li>
                            <li>Perform rotations for different cases</li>
                            <li>Insert and delete with rebalancing</li>
                        </ul>
                    </li>
                    
                    <li><strong>B-Tree Operations:</strong>
                        <ul>
                            <li>Insert with node splitting</li>
                            <li>Delete with node merging</li>
                            <li>Compare with other tree structures</li>
                        </ul>
                    </li>
                </ol>
                
                <div class="example">
                    <div class="example-title">üìù Sample Exam Question</div>
                    <p><strong>Question:</strong> Construct a Binary Search Tree by inserting the following elements in order: 45, 30, 60, 20, 35, 50, 70, 25, 40. Perform inorder, preorder, and postorder traversals. Then delete node 30 and show the resulting tree structure.</p>
                    <p><strong>Solution Approach:</strong>
                    <br>1. Insert elements one by one following BST rules
                    <br>2. Perform traversals:
                    <br>   - Inorder: Left-Root-Right (produces sorted output)
                    <br>   - Preorder: Root-Left-Right
                    <br>   - Postorder: Left-Right-Root
                    <br>3. Delete node 30 (has two children):
                    <br>   - Find inorder successor (minimum in right subtree = 35)
                    <br>   - Replace 30 with 35
                    <br>   - Delete the original 35 node (which has only right child 40)
                    <br>4. Show final tree structure</p>
                </div>
                
                <p><strong>Study Strategy:</strong></p>
                <ul>
                    <li>Master tree terminology and mathematical properties</li>
                    <li>Practice all traversal algorithms (recursive and iterative)</li>
                    <li>Understand BST operations and edge cases</li>
                    <li>Learn AVL tree rotations and balancing techniques</li>
                    <li>Practice B-Tree operations with different orders</li>
                    <li>Work through previous year question papers</li>
                </ul>
                
                <div class="formula">
                    Exam Success = Tree Properties + Traversal Algorithms + BST Operations + Balancing Techniques
                </div>
            </div>
        </div>
    </div>
        <div class="header">
        <h2 class="subtitle">Module 4: Graphs</h2>
    </div>

    <div class="section">
        <h2 class="section-title">1. Graph Representation</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üï∏Ô∏è For a 5-Year-Old: What are Graphs?</div>
                <p>Imagine a big spider web! Some points are connected by threads, and some aren't. You can travel from one point to another if there's a thread connecting them. Graphs in computers are just like this - they're made of points (called vertices) connected by lines (called edges), and they help us understand how things are connected!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîó Formal Definition & Mathematical Foundation</div>
                <p><strong>Graph</strong> G = (V, E) is a mathematical structure consisting of a set of vertices (V) and a set of edges (E) that connect pairs of vertices.</p>
                
                <div class="svg-container">
                    <svg width="700" height="400" viewBox="0 0 700 400" xmlns="http://www.w3.org/2000/svg">
                        <!-- Graph Example -->
                        <g transform="translate(350, 50)">
                            <text x="0" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Undirected Graph Example</text>
                            
                            <!-- Vertices -->
                            <circle cx="0" cy="80" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="0" y="85" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            
                            <circle cx="-100" cy="160" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-100" y="165" text-anchor="middle" fill="white" font-weight="bold">B</text>
                            
                            <circle cx="100" cy="160" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="165" text-anchor="middle" fill="white" font-weight="bold">C</text>
                            
                            <circle cx="-150" cy="260" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-150" y="265" text-anchor="middle" fill="white" font-weight="bold">D</text>
                            
                            <circle cx="0" cy="260" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="0" y="265" text-anchor="middle" fill="white" font-weight="bold">E</text>
                            
                            <circle cx="150" cy="260" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="265" text-anchor="middle" fill="white" font-weight="bold">F</text>
                            
                            <!-- Edges -->
                            <line x1="0" y1="100" x2="-100" y2="140" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="0" y1="100" x2="100" y2="140" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-100" y1="180" x2="-150" y2="240" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-100" y1="180" x2="0" y2="240" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="100" y1="180" x2="0" y2="240" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="100" y1="180" x2="150" y2="240" stroke="#2c3e50" stroke-width="2"/>
                            
                            <!-- Labels -->
                            <text x="-200" y="200" font-size="12" fill="#7f8c8d">Vertices: V = {A, B, C, D, E, F}</text>
                            <text x="-200" y="220" font-size="12" fill="#7f8c8d">Edges: E = {(A,B), (A,C), (B,D), (B,E), (C,E), (C,F)}</text>
                        </g>
                        
                        <!-- Directed Graph -->
                        <g transform="translate(50, 320)">
                            <text x="150" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Directed Graph (Digraph)</text>
                            
                            <!-- Vertices -->
                            <circle cx="50" cy="40" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="45" text-anchor="middle" fill="white" font-size="12">1</text>
                            
                            <circle cx="150" cy="40" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="45" text-anchor="middle" fill="white" font-size="12">2</text>
                            
                            <circle cx="250" cy="40" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="250" y="45" text-anchor="middle" fill="white" font-size="12">3</text>
                            
                            <!-- Directed edges with arrows -->
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                                </marker>
                            </defs>
                            
                            <line x1="65" y1="40" x2="135" y2="40" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                            <line x1="165" y1="40" x2="235" y2="40" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                            <line x1="250" y1="55" x2="150" y2="55" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 1: Undirected and Directed Graph Examples</div>
                </div>
                
                <p><strong>Graph Terminology:</strong></p>
                <ul>
                    <li><strong>Vertex (Node):</strong> Fundamental unit of graph</li>
                    <li><strong>Edge:</strong> Connection between two vertices</li>
                    <li><strong>Degree:</strong> Number of edges incident to a vertex</li>
                    <li><strong>Path:</strong> Sequence of vertices connected by edges</li>
                    <li><strong>Cycle:</strong> Path that starts and ends at same vertex</li>
                    <li><strong>Connected Graph:</strong> Path exists between any two vertices</li>
                    <li><strong>Weighted Graph:</strong> Edges have associated weights/costs</li>
                </ul>
                
                <p><strong>Graph Types:</strong></p>
                <ul>
                    <li><strong>Undirected Graph:</strong> Edges have no direction</li>
                    <li><strong>Directed Graph (Digraph):</strong> Edges have direction</li>
                    <li><strong>Weighted Graph:</strong> Edges have weights</li>
                    <li><strong>Unweighted Graph:</strong> All edges have equal weight</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üìä Graph Properties Calculation</div>
                    <p>For the undirected graph in Figure 1:</p>
                    <ul>
                        <li><strong>Number of vertices (|V|):</strong> 6</li>
                        <li><strong>Number of edges (|E|):</strong> 6</li>
                        <li><strong>Degree of vertex A:</strong> 2 (connected to B and C)</li>
                        <li><strong>Degree of vertex B:</strong> 3 (connected to A, D, E)</li>
                        <li><strong>Degree of vertex C:</strong> 3 (connected to A, E, F)</li>
                        <li><strong>Degree of vertex D:</strong> 1 (connected to B)</li>
                        <li><strong>Degree of vertex E:</strong> 2 (connected to B, C)</li>
                        <li><strong>Degree of vertex F:</strong> 1 (connected to C)</li>
                    </ul>
                </div>
                
                <div class="formula">
                    For undirected graph: Œ£(degree(v)) = 2|E|
                    <br>
                    For directed graph: Œ£(in-degree(v)) = Œ£(out-degree(v)) = |E|
                    <br>
                    Maximum edges in simple graph: |E| ‚â§ |V|(|V|-1)/2 (undirected)
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">2. Graph Representation Methods</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üìã For a 5-Year-Old: How Do We Store Graphs?</div>
                <p>Imagine you have two ways to remember your friends' connections! One way is to make a big chart where you put a checkmark if two friends are connected. Another way is to have a list for each friend showing who they're connected to. Graphs in computers can be stored in these same two ways - one is like a chart and the other is like lists!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üíæ Adjacency Matrix vs Adjacency List</div>
                <p><strong>Graph Representation</strong> refers to how we store graph information in computer memory. The two primary methods are Adjacency Matrix and Adjacency List.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- Sample Graph -->
                        <g transform="translate(100, 50)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Sample Graph</text>
                            
                            <!-- Vertices -->
                            <circle cx="100" cy="50" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="55" text-anchor="middle" fill="white" font-size="12">0</text>
                            
                            <circle cx="50" cy="120" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="125" text-anchor="middle" fill="white" font-size="12">1</text>
                            
                            <circle cx="150" cy="120" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="125" text-anchor="middle" fill="white" font-size="12">2</text>
                            
                            <circle cx="100" cy="190" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="195" text-anchor="middle" fill="white" font-size="12">3</text>
                            
                            <!-- Edges -->
                            <line x1="100" y1="65" x2="50" y2="105" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="100" y1="65" x2="150" y2="105" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="50" y1="135" x2="100" y2="175" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="150" y1="135" x2="100" y2="175" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="50" y1="120" x2="150" y2="120" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        
                        <!-- Adjacency Matrix -->
                        <g transform="translate(350, 50)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Adjacency Matrix</text>
                            
                            <!-- Matrix grid -->
                            <g transform="translate(20, 20)">
                                <!-- Header row -->
                                <rect x="30" y="0" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="45" y="17" text-anchor="middle" fill="white" font-size="12">0</text>
                                
                                <rect x="60" y="0" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="75" y="17" text-anchor="middle" fill="white" font-size="12">1</text>
                                
                                <rect x="90" y="0" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="105" y="17" text-anchor="middle" fill="white" font-size="12">2</text>
                                
                                <rect x="120" y="0" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="135" y="17" text-anchor="middle" fill="white" font-size="12">3</text>
                                
                                <!-- Row 0 -->
                                <rect x="0" y="25" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="15" y="42" text-anchor="middle" fill="white" font-size="12">0</text>
                                
                                <rect x="30" y="25" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="42" text-anchor="middle">0</text>
                                
                                <rect x="60" y="25" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="42" text-anchor="middle">1</text>
                                
                                <rect x="90" y="25" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="42" text-anchor="middle">1</text>
                                
                                <rect x="120" y="25" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="42" text-anchor="middle">0</text>
                                
                                <!-- Row 1 -->
                                <rect x="0" y="50" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="15" y="67" text-anchor="middle" fill="white" font-size="12">1</text>
                                
                                <rect x="30" y="50" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="67" text-anchor="middle">1</text>
                                
                                <rect x="60" y="50" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="67" text-anchor="middle">0</text>
                                
                                <rect x="90" y="50" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="67" text-anchor="middle">1</text>
                                
                                <rect x="120" y="50" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="67" text-anchor="middle">1</text>
                                
                                <!-- Row 2 -->
                                <rect x="0" y="75" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="15" y="92" text-anchor="middle" fill="white" font-size="12">2</text>
                                
                                <rect x="30" y="75" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="92" text-anchor="middle">1</text>
                                
                                <rect x="60" y="75" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="92" text-anchor="middle">0</text>
                                
                                <rect x="90" y="75" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="92" text-anchor="middle">0</text>
                                
                                <rect x="120" y="75" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="92" text-anchor="middle">1</text>
                                
                                <!-- Row 3 -->
                                <rect x="0" y="100" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="15" y="117" text-anchor="middle" fill="white" font-size="12">3</text>
                                
                                <rect x="30" y="100" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="117" text-anchor="middle">0</text>
                                
                                <rect x="60" y="100" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="75" y="117" text-anchor="middle">1</text>
                                
                                <rect x="90" y="100" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="117" text-anchor="middle">1</text>
                                
                                <rect x="120" y="100" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="135" y="117" text-anchor="middle">0</text>
                            </g>
                        </g>
                        
                        <!-- Adjacency List -->
                        <g transform="translate(100, 280)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Adjacency List</text>
                            
                            <!-- List representation -->
                            <g transform="translate(20, 20)">
                                <!-- Vertex 0 -->
                                <rect x="0" y="0" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="15" y="17" text-anchor="middle" fill="white" font-size="12">0</text>
                                
                                <rect x="30" y="0" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="17" text-anchor="middle">‚Üí</text>
                                
                                <rect x="60" y="0" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="75" y="17" text-anchor="middle" fill="white">1</text>
                                
                                <rect x="90" y="0" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="17" text-anchor="middle">‚Üí</text>
                                
                                <rect x="120" y="0" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="135" y="17" text-anchor="middle" fill="white">2</text>
                                
                                <rect x="150" y="0" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="165" y="17" text-anchor="middle">‚Üí</text>
                                
                                <rect x="180" y="0" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="195" y="17" text-anchor="middle">NULL</text>
                                
                                <!-- Vertex 1 -->
                                <rect x="0" y="30" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="15" y="47" text-anchor="middle" fill="white" font-size="12">1</text>
                                
                                <rect x="30" y="30" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="47" text-anchor="middle">‚Üí</text>
                                
                                <rect x="60" y="30" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="75" y="47" text-anchor="middle" fill="white">0</text>
                                
                                <rect x="90" y="30" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="47" text-anchor="middle">‚Üí</text>
                                
                                <rect x="120" y="30" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="135" y="47" text-anchor="middle" fill="white">2</text>
                                
                                <rect x="150" y="30" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="165" y="47" text-anchor="middle">‚Üí</text>
                                
                                <rect x="180" y="30" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="195" y="47" text-anchor="middle" fill="white">3</text>
                                
                                <!-- Vertex 2 -->
                                <rect x="0" y="60" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="15" y="77" text-anchor="middle" fill="white" font-size="12">2</text>
                                
                                <rect x="30" y="60" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="77" text-anchor="middle">‚Üí</text>
                                
                                <rect x="60" y="60" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="75" y="77" text-anchor="middle" fill="white">0</text>
                                
                                <rect x="90" y="60" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="77" text-anchor="middle">‚Üí</text>
                                
                                <rect x="120" y="60" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="135" y="77" text-anchor="middle" fill="white">3</text>
                                
                                <!-- Vertex 3 -->
                                <rect x="0" y="90" width="30" height="25" fill="#34495e" stroke="#2c3e50"/>
                                <text x="15" y="107" text-anchor="middle" fill="white" font-size="12">3</text>
                                
                                <rect x="30" y="90" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="45" y="107" text-anchor="middle">‚Üí</text>
                                
                                <rect x="60" y="90" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="75" y="107" text-anchor="middle" fill="white">1</text>
                                
                                <rect x="90" y="90" width="30" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                                <text x="105" y="107" text-anchor="middle">‚Üí</text>
                                
                                <rect x="120" y="90" width="30" height="25" fill="#3498db" stroke="#2c3e50"/>
                                <text x="135" y="107" text-anchor="middle" fill="white">2</text>
                            </g>
                        </g>
                        
                        <!-- Comparison -->
                        <g transform="translate(400, 280)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Comparison</text>
                            
                            <rect x="0" y="20" width="80" height="25" fill="#34495e" stroke="#2c3e50"/>
                            <text x="40" y="37" text-anchor="middle" fill="white" font-weight="bold">Aspect</text>
                            
                            <rect x="80" y="20" width="100" height="25" fill="#34495e" stroke="#2c3e50"/>
                            <text x="130" y="37" text-anchor="middle" fill="white" font-weight="bold">Matrix</text>
                            
                            <rect x="180" y="20" width="100" height="25" fill="#34495e" stroke="#2c3e50"/>
                            <text x="230" y="37" text-anchor="middle" fill="white" font-weight="bold">List</text>
                            
                            <!-- Space -->
                            <rect x="0" y="45" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="40" y="62" text-anchor="middle">Space</text>
                            
                            <rect x="80" y="45" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="130" y="62" text-anchor="middle">O(V¬≤)</text>
                            
                            <rect x="180" y="45" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="230" y="62" text-anchor="middle">O(V+E)</text>
                            
                            <!-- Edge Check -->
                            <rect x="0" y="70" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="40" y="87" text-anchor="middle">Edge Check</text>
                            
                            <rect x="80" y="70" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="130" y="87" text-anchor="middle">O(1)</text>
                            
                            <rect x="180" y="70" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="230" y="87" text-anchor="middle">O(deg(v))</text>
                            
                            <!-- Best For -->
                            <rect x="0" y="95" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="40" y="112" text-anchor="middle">Best For</text>
                            
                            <rect x="80" y="95" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="130" y="112" text-anchor="middle">Dense graphs</text>
                            
                            <rect x="180" y="95" width="100" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="230" y="112" text-anchor="middle">Sparse graphs</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 2: Graph Representation Methods Comparison</div>
                </div>
                
                <p><strong>Adjacency Matrix:</strong></p>
                <ul>
                    <li><strong>Structure:</strong> 2D array where matrix[i][j] = 1 if edge exists between i and j</li>
                    <li><strong>Space Complexity:</strong> O(V¬≤) where V is number of vertices</li>
                    <li><strong>Edge Check:</strong> O(1) time</li>
                    <li><strong>Best For:</strong> Dense graphs, frequent edge checks</li>
                </ul>
                
                <p><strong>Adjacency List:</strong></p>
                <ul>
                    <li><strong>Structure:</strong> Array of linked lists, each containing adjacent vertices</li>
                    <li><strong>Space Complexity:</strong> O(V + E) where V is vertices, E is edges</li>
                    <li><strong>Edge Check:</strong> O(degree(v)) time</li>
                    <li><strong>Best For:</strong> Sparse graphs, memory efficiency</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Graph Representation Implementation</div>
                    <div class="code">
// Adjacency Matrix Representation
#define MAX_VERTICES 100

typedef struct {
    int matrix[MAX_VERTICES][MAX_VERTICES];
    int numVertices;
} GraphMatrix;

void initMatrix(GraphMatrix* g, int vertices) {
    g->numVertices = vertices;
    for (int i = 0; i < vertices; i++) {
        for (int j = 0; j < vertices; j++) {
            g->matrix[i][j] = 0;
        }
    }
}

void addEdgeMatrix(GraphMatrix* g, int src, int dest) {
    if (src < g->numVertices && dest < g->numVertices) {
        g->matrix[src][dest] = 1;
        g->matrix[dest][src] = 1; // For undirected graph
    }
}

// Adjacency List Representation
typedef struct Node {
    int vertex;
    struct Node* next;
} Node;

typedef struct {
    Node** adjLists;
    int numVertices;
} GraphList;

Node* createNode(int v) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->vertex = v;
    newNode->next = NULL;
    return newNode;
}

void initList(GraphList* g, int vertices) {
    g->numVertices = vertices;
    g->adjLists = (Node**)malloc(vertices * sizeof(Node*));
    
    for (int i = 0; i < vertices; i++) {
        g->adjLists[i] = NULL;
    }
}

void addEdgeList(GraphList* g, int src, int dest) {
    // Add edge from src to dest
    Node* newNode = createNode(dest);
    newNode->next = g->adjLists[src];
    g->adjLists[src] = newNode;
    
    // Add edge from dest to src (for undirected graph)
    newNode = createNode(src);
    newNode->next = g->adjLists[dest];
    g->adjLists[dest] = newNode;
}
                    </div>
                </div>
                
                <div class="formula">
                    Space Complexity Comparison:
                    <br>
                    ‚Ä¢ Adjacency Matrix: S = O(V¬≤)
                    <br>
                    ‚Ä¢ Adjacency List: S = O(V + E)
                    <br>
                    ‚Ä¢ Matrix preferred when E ‚âà V¬≤ (dense graphs)
                    <br>
                    ‚Ä¢ List preferred when E ‚âà V (sparse graphs)
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">3. Graph Traversal: BFS and DFS</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üö∂‚Äç‚ôÇÔ∏è For a 5-Year-Old: How Do We Explore Graphs?</div>
                <p>Imagine you're exploring a maze! One way is to check all the paths close to you first before going deeper - that's like BFS. Another way is to follow one path as far as you can, then backtrack and try another path - that's like DFS. Both are different ways to make sure you visit every part of the maze (or graph)!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîç Breadth-First Search (BFS) and Depth-First Search (DFS)</div>
                <p><strong>Graph Traversal</strong> is the process of visiting all vertices in a graph. The two fundamental traversal algorithms are BFS and DFS.</p>
                
                <div class="svg-container">
                    <svg width="700" height="600" viewBox="0 0 700 600" xmlns="http://www.w3.org/2000/svg">
                        <!-- Sample Graph for Traversal -->
                        <g transform="translate(350, 50)">
                            <text x="0" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Sample Graph for BFS and DFS</text>
                            
                            <!-- Vertices -->
                            <circle cx="0" cy="60" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="0" y="65" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            
                            <circle cx="-100" cy="140" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-100" y="145" text-anchor="middle" fill="white" font-weight="bold">B</text>
                            
                            <circle cx="100" cy="140" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="145" text-anchor="middle" fill="white" font-weight="bold">C</text>
                            
                            <circle cx="-150" cy="240" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-150" y="245" text-anchor="middle" fill="white" font-weight="bold">D</text>
                            
                            <circle cx="-50" cy="240" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-50" y="245" text-anchor="middle" fill="white" font-weight="bold">E</text>
                            
                            <circle cx="50" cy="240" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="245" text-anchor="middle" fill="white" font-weight="bold">F</text>
                            
                            <circle cx="150" cy="240" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="245" text-anchor="middle" fill="white" font-weight="bold">G</text>
                            
                            <!-- Edges -->
                            <line x1="0" y1="80" x2="-100" y2="120" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="0" y1="80" x2="100" y2="120" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-100" y1="160" x2="-150" y2="220" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-100" y1="160" x2="-50" y2="220" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="100" y1="160" x2="50" y2="220" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="100" y1="160" x2="150" y2="220" stroke="#2c3e50" stroke-width="2"/>
                            <line x1="-50" y1="240" x2="50" y2="240" stroke="#2c3e50" stroke-width="2"/>
                        </g>
                        
                        <!-- BFS Traversal Order -->
                        <g transform="translate(50, 340)">
                            <text x="150" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">BFS Traversal Order (Level by Level)</text>
                            
                            <!-- Level 0 -->
                            <rect x="50" y="20" width="40" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="70" y="40" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            <text x="70" y="60" text-anchor="middle" font-size="10" fill="#e74c3c">Level 0</text>
                            
                            <!-- Level 1 -->
                            <rect x="120" y="20" width="40" height="30" fill="#f39c12" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="140" y="40" text-anchor="middle" fill="white" font-weight="bold">B</text>
                            
                            <rect x="170" y="20" width="40" height="30" fill="#f39c12" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="190" y="40" text-anchor="middle" fill="white" font-weight="bold">C</text>
                            <text x="165" y="60" text-anchor="middle" font-size="10" fill="#f39c12">Level 1</text>
                            
                            <!-- Level 2 -->
                            <rect x="220" y="20" width="40" height="30" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="240" y="40" text-anchor="middle" fill="white" font-weight="bold">D</text>
                            
                            <rect x="270" y="20" width="40" height="30" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="290" y="40" text-anchor="middle" fill="white" font-weight="bold">E</text>
                            
                            <rect x="320" y="20" width="40" height="30" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="340" y="40" text-anchor="middle" fill="white" font-weight="bold">F</text>
                            
                            <rect x="370" y="20" width="40" height="30" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="390" y="40" text-anchor="middle" fill="white" font-weight="bold">G</text>
                            <text x="315" y="60" text-anchor="middle" font-size="10" fill="#27ae60">Level 2</text>
                            
                            <!-- BFS result -->
                            <text x="230" y="90" text-anchor="middle" font-size="14" fill="#2c3e50">BFS Order: A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F ‚Üí G</text>
                        </g>
                        
                        <!-- DFS Traversal Order -->
                        <g transform="translate(400, 340)">
                            <text x="150" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">DFS Traversal Order (Depth First)</text>
                            
                            <!-- DFS path visualization -->
                            <rect x="50" y="20" width="40" height="30" fill="#e74c3c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="70" y="40" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            
                            <rect x="100" y="20" width="40" height="30" fill="#f39c12" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="120" y="40" text-anchor="middle" fill="white" font-weight="bold">B</text>
                            
                            <rect x="150" y="20" width="40" height="30" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="170" y="40" text-anchor="middle" fill="white" font-weight="bold">D</text>
                            
                            <rect x="200" y="20" width="40" height="30" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="220" y="40" text-anchor="middle" fill="white" font-weight="bold">E</text>
                            
                            <rect x="250" y="20" width="40" height="30" fill="#9b59b6" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="270" y="40" text-anchor="middle" fill="white" font-weight="bold">F</text>
                            
                            <rect x="300" y="20" width="40" height="30" fill="#e67e22" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="320" y="40" text-anchor="middle" fill="white" font-weight="bold">C</text>
                            
                            <rect x="350" y="20" width="40" height="30" fill="#1abc9c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="370" y="40" text-anchor="middle" fill="white" font-weight="bold">G</text>
                            
                            <!-- DFS result -->
                            <text x="230" y="90" text-anchor="middle" font-size="14" fill="#2c3e50">DFS Order: A ‚Üí B ‚Üí D ‚Üí E ‚Üí F ‚Üí C ‚Üí G</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 3: BFS and DFS Traversal Comparison</div>
                </div>
                
                <p><strong>Breadth-First Search (BFS):</strong></p>
                <ul>
                    <li><strong>Strategy:</strong> Explore neighbors first, then neighbors of neighbors</li>
                    <li><strong>Data Structure:</strong> Queue (FIFO)</li>
                    <li><strong>Time Complexity:</strong> O(V + E)</li>
                    <li><strong>Space Complexity:</strong> O(V) for queue and visited array</li>
                    <li><strong>Applications:</strong> Shortest path in unweighted graphs, level-order traversal</li>
                </ul>
                
                <p><strong>Depth-First Search (DFS):</strong></p>
                <ul>
                    <li><strong>Strategy:</strong> Explore as far as possible along each branch before backtracking</li>
                    <li><strong>Data Structure:</strong> Stack (LIFO) or recursion</li>
                    <li><strong>Time Complexity:</strong> O(V + E)</li>
                    <li><strong>Space Complexity:</strong> O(V) for stack/ recursion and visited array</li>
                    <li><strong>Applications:</strong> Topological sorting, cycle detection, connected components</li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª BFS and DFS Implementation</div>
                    <div class="code">
// BFS Implementation using Queue
#include <stdbool.h>
#include <stdlib.h>

#define MAX_VERTICES 100

typedef struct {
    int items[MAX_VERTICES];
    int front, rear;
} Queue;

void initQueue(Queue* q) {
    q->front = q->rear = -1;
}

void enqueue(Queue* q, int value) {
    if (q->rear == MAX_VERTICES - 1) return;
    if (q->front == -1) q->front = 0;
    q->items[++q->rear] = value;
}

int dequeue(Queue* q) {
    if (q->front == -1) return -1;
    int item = q->items[q->front++];
    if (q->front > q->rear) q->front = q->rear = -1;
    return item;
}

bool isEmpty(Queue* q) {
    return q->front == -1;
}

void BFS(GraphList* g, int startVertex) {
    bool visited[MAX_VERTICES] = {false};
    Queue q;
    initQueue(&q);
    
    visited[startVertex] = true;
    enqueue(&q, startVertex);
    
    printf("BFS traversal starting from vertex %d: ", startVertex);
    
    while (!isEmpty(&q)) {
        int currentVertex = dequeue(&q);
        printf("%d ", currentVertex);
        
        Node* temp = g->adjLists[currentVertex];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            if (!visited[adjVertex]) {
                visited[adjVertex] = true;
                enqueue(&q, adjVertex);
            }
            temp = temp->next;
        }
    }
    printf("\n");
}

// DFS Implementation using Recursion
void DFSUtil(GraphList* g, int vertex, bool visited[]) {
    visited[vertex] = true;
    printf("%d ", vertex);
    
    Node* temp = g->adjLists[vertex];
    while (temp != NULL) {
        int adjVertex = temp->vertex;
        if (!visited[adjVertex]) {
            DFSUtil(g, adjVertex, visited);
        }
        temp = temp->next;
    }
}

void DFS(GraphList* g, int startVertex) {
    bool visited[MAX_VERTICES] = {false};
    printf("DFS traversal starting from vertex %d: ", startVertex);
    DFSUtil(g, startVertex, visited);
    printf("\n");
}

// Iterative DFS using Stack
typedef struct {
    int items[MAX_VERTICES];
    int top;
} Stack;

void initStack(Stack* s) {
    s->top = -1;
}

void push(Stack* s, int value) {
    if (s->top == MAX_VERTICES - 1) return;
    s->items[++s->top] = value;
}

int pop(Stack* s) {
    if (s->top == -1) return -1;
    return s->items[s->top--];
}

bool isStackEmpty(Stack* s) {
    return s->top == -1;
}

void DFSIterative(GraphList* g, int startVertex) {
    bool visited[MAX_VERTICES] = {false};
    Stack s;
    initStack(&s);
    
    printf("Iterative DFS starting from vertex %d: ", startVertex);
    
    push(&s, startVertex);
    
    while (!isStackEmpty(&s)) {
        int currentVertex = pop(&s);
        
        if (!visited[currentVertex]) {
            visited[currentVertex] = true;
            printf("%d ", currentVertex);
            
            // Push all adjacent vertices in reverse order
            Node* temp = g->adjLists[currentVertex];
            // First, collect all adjacent vertices
            int adjVertices[MAX_VERTICES];
            int count = 0;
            while (temp != NULL) {
                adjVertices[count++] = temp->vertex;
                temp = temp->next;
            }
            // Push in reverse order
            for (int i = count - 1; i >= 0; i--) {
                if (!visited[adjVertices[i]]) {
                    push(&s, adjVertices[i]);
                }
            }
        }
    }
    printf("\n");
}
                    </div>
                </div>
                
                <div class="formula">
                    Time Complexity: T(V, E) = O(V + E) for both BFS and DFS
                    <br>
                    Space Complexity: S(V) = O(V) for both algorithms
                    <br>
                    BFS uses Queue, DFS uses Stack/Recursion
                    <br>
                    Both require visited array to avoid cycles
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">4. Spanning Trees and Shortest Path Algorithms</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üåâ For a 5-Year-Old: What are Spanning Trees and Shortest Paths?</div>
                <p>Imagine you have a big map of cities connected by roads! A spanning tree is like finding the fewest roads needed to connect all cities without any loops. The shortest path is like finding the quickest way to get from your city to your friend's city. Both help us solve problems about connections and distances!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üåê Minimum Spanning Trees and Shortest Path Algorithms</div>
                <p><strong>Spanning Tree</strong> of a connected, undirected graph is a subgraph that is a tree and connects all vertices together. <strong>Minimum Spanning Tree (MST)</strong> has the minimum possible total edge weight.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- Weighted Graph -->
                        <g transform="translate(100, 50)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Weighted Graph</text>
                            
                            <!-- Vertices -->
                            <circle cx="100" cy="50" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="55" text-anchor="middle" fill="white" font-size="12">A</text>
                            
                            <circle cx="50" cy="120" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="125" text-anchor="middle" fill="white" font-size="12">B</text>
                            
                            <circle cx="150" cy="120" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="125" text-anchor="middle" fill="white" font-size="12">C</text>
                            
                            <circle cx="100" cy="190" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="195" text-anchor="middle" fill="white" font-size="12">D</text>
                            
                            <!-- Weighted edges -->
                            <line x1="100" y1="65" x2="50" y2="105" stroke="#2c3e50" stroke-width="2"/>
                            <text x="65" y="80" text-anchor="middle" font-size="10" fill="#e74c3c">4</text>
                            
                            <line x1="100" y1="65" x2="150" y2="105" stroke="#2c3e50" stroke-width="2"/>
                            <text x="135" y="80" text-anchor="middle" font-size="10" fill="#e74c3c">3</text>
                            
                            <line x1="50" y1="135" x2="100" y2="175" stroke="#2c3e50" stroke-width="2"/>
                            <text x="65" y="160" text-anchor="middle" font-size="10" fill="#e74c3c">2</text>
                            
                            <line x1="150" y1="135" x2="100" y2="175" stroke="#2c3e50" stroke-width="2"/>
                            <text x="135" y="160" text-anchor="middle" font-size="10" fill="#e74c3c">5</text>
                            
                            <line x1="50" y1="120" x2="150" y2="120" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="115" text-anchor="middle" font-size="10" fill="#e74c3c">6</text>
                        </g>
                        
                        <!-- Minimum Spanning Tree -->
                        <g transform="translate(350, 50)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Minimum Spanning Tree</text>
                            
                            <!-- Vertices -->
                            <circle cx="100" cy="50" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="55" text-anchor="middle" fill="white" font-size="12">A</text>
                            
                            <circle cx="50" cy="120" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="125" text-anchor="middle" fill="white" font-size="12">B</text>
                            
                            <circle cx="150" cy="120" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="125" text-anchor="middle" fill="white" font-size="12">C</text>
                            
                            <circle cx="100" cy="190" r="15" fill="#27ae60" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="195" text-anchor="middle" fill="white" font-size="12">D</text>
                            
                            <!-- MST edges (selected) -->
                            <line x1="100" y1="65" x2="150" y2="105" stroke="#27ae60" stroke-width="3"/>
                            <text x="135" y="80" text-anchor="middle" font-size="10" fill="#27ae60">3</text>
                            
                            <line x1="50" y1="135" x2="100" y2="175" stroke="#27ae60" stroke-width="3"/>
                            <text x="65" y="160" text-anchor="middle" font-size="10" fill="#27ae60">2</text>
                            
                            <line x1="100" y1="65" x2="50" y2="105" stroke="#27ae60" stroke-width="3"/>
                            <text x="65" y="80" text-anchor="middle" font-size="10" fill="#27ae60">4</text>
                            
                            <!-- Total weight -->
                            <text x="100" y="230" text-anchor="middle" font-size="12" fill="#27ae60" font-weight="bold">Total Weight = 3 + 2 + 4 = 9</text>
                        </g>
                        
                        <!-- Shortest Path -->
                        <g transform="translate(100, 280)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Shortest Path: A to D</text>
                            
                            <!-- Vertices -->
                            <circle cx="100" cy="50" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="55" text-anchor="middle" fill="white" font-size="12">A</text>
                            
                            <circle cx="50" cy="120" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="50" y="125" text-anchor="middle" fill="white" font-size="12">B</text>
                            
                            <circle cx="150" cy="120" r="15" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="150" y="125" text-anchor="middle" fill="white" font-size="12">C</text>
                            
                            <circle cx="100" cy="190" r="15" fill="#e74c3c" stroke="#2c3e50" stroke-width="2"/>
                            <text x="100" y="195" text-anchor="middle" fill="white" font-size="12">D</text>
                            
                            <!-- All edges (faded) -->
                            <line x1="100" y1="65" x2="50" y2="105" stroke="#bdc3c7" stroke-width="1" stroke-dasharray="3,3"/>
                            <line x1="100" y1="65" x2="150" y2="105" stroke="#bdc3c7" stroke-width="1" stroke-dasharray="3,3"/>
                            <line x1="50" y1="135" x2="100" y2="175" stroke="#bdc3c7" stroke-width="1" stroke-dasharray="3,3"/>
                            <line x1="150" y1="135" x2="100" y2="175" stroke="#bdc3c7" stroke-width="1" stroke-dasharray="3,3"/>
                            <line x1="50" y1="120" x2="150" y2="120" stroke="#bdc3c7" stroke-width="1" stroke-dasharray="3,3"/>
                            
                            <!-- Shortest path (highlighted) -->
                            <line x1="100" y1="65" x2="150" y2="105" stroke="#e74c3c" stroke-width="3"/>
                            <text x="135" y="80" text-anchor="middle" font-size="10" fill="#e74c3c">3</text>
                            
                            <line x1="150" y1="135" x2="100" y2="175" stroke="#e74c3c" stroke-width="3"/>
                            <text x="135" y="160" text-anchor="middle" font-size="10" fill="#e74c3c">5</text>
                            
                            <!-- Path info -->
                            <text x="100" y="230" text-anchor="middle" font-size="12" fill="#e74c3c" font-weight="bold">Path: A ‚Üí C ‚Üí D</text>
                            <text x="100" y="245" text-anchor="middle" font-size="12" fill="#e74c3c" font-weight="bold">Total Distance = 3 + 5 = 8</text>
                        </g>
                        
                        <!-- Algorithm Comparison -->
                        <g transform="translate(400, 280)">
                            <text x="100" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Algorithm Comparison</text>
                            
                            <rect x="0" y="20" width="80" height="25" fill="#34495e" stroke="#2c3e50"/>
                            <text x="40" y="37" text-anchor="middle" fill="white" font-weight="bold">Algorithm</text>
                            
                            <rect x="80" y="20" width="120" height="25" fill="#34495e" stroke="#2c3e50"/>
                            <text x="140" y="37" text-anchor="middle" fill="white" font-weight="bold">Purpose</text>
                            
                            <rect x="200" y="20" width="80" height="25" fill="#34495e" stroke="#2c3e50"/>
                            <text x="240" y="37" text-anchor="middle" fill="white" font-weight="bold">Complexity</text>
                            
                            <!-- Kruskal -->
                            <rect x="0" y="45" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="40" y="62" text-anchor="middle">Kruskal</text>
                            
                            <rect x="80" y="45" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="140" y="62" text-anchor="middle">MST</text>
                            
                            <rect x="200" y="45" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="240" y="62" text-anchor="middle">O(E log E)</text>
                            
                            <!-- Prim -->
                            <rect x="0" y="70" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="40" y="87" text-anchor="middle">Prim</text>
                            
                            <rect x="80" y="70" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="140" y="87" text-anchor="middle">MST</text>
                            
                            <rect x="200" y="70" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="240" y="87" text-anchor="middle">O(E log V)</text>
                            
                            <!-- Dijkstra -->
                            <rect x="0" y="95" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="40" y="112" text-anchor="middle">Dijkstra</text>
                            
                            <rect x="80" y="95" width="120" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="140" y="112" text-anchor="middle">Shortest Path</text>
                            
                            <rect x="200" y="95" width="80" height="25" fill="#ecf0f1" stroke="#2c3e50"/>
                            <text x="240" y="112" text-anchor="middle">O(E log V)</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 4: Spanning Trees and Shortest Path Algorithms</div>
                </div>
                
                <p><strong>Minimum Spanning Tree Algorithms:</strong></p>
                <ul>
                    <li><strong>Kruskal's Algorithm:</strong>
                        <ul>
                            <li>Sort all edges by weight</li>
                            <li>Add edges in increasing order, skip if cycle forms</li>
                            <li>Uses Union-Find data structure</li>
                            <li>Time Complexity: O(E log E)</li>
                        </ul>
                    </li>
                    <li><strong>Prim's Algorithm:</strong>
                        <ul>
                            <li>Start with arbitrary vertex</li>
                            <li>Add minimum weight edge connecting to tree</li>
                            <li>Uses priority queue</li>
                            <li>Time Complexity: O(E log V)</li>
                        </ul>
                    </li>
                </ul>
                
                <p><strong>Shortest Path Algorithms:</strong></p>
                <ul>
                    <li><strong>Dijkstra's Algorithm:</strong>
                        <ul>
                            <li>Finds shortest path from single source</li>
                            <li>Works for non-negative edge weights</li>
                            <li>Uses priority queue</li>
                            <li>Time Complexity: O(E log V)</li>
                        </ul>
                    </li>
                    <li><strong>Bellman-Ford Algorithm:</strong>
                        <ul>
                            <li>Handles negative edge weights</li>
                            <li>Detects negative cycles</li>
                            <li>Time Complexity: O(V √ó E)</li>
                        </ul>
                    </li>
                    <li><strong>Floyd-Warshall Algorithm:</strong>
                        <ul>
                            <li>Finds shortest paths between all pairs</li>
                            <li>Handles negative weights (no cycles)</li>
                            <li>Time Complexity: O(V¬≥)</li>
                        </ul>
                    </li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Dijkstra's Algorithm Implementation</div>
                    <div class="code">
#include <limits.h>
#include <stdbool.h>

#define MAX_VERTICES 100
#define INF INT_MAX

typedef struct {
    int vertex;
    int distance;
} MinHeapNode;

typedef struct {
    MinHeapNode* array;
    int size;
    int capacity;
} MinHeap;

// Dijkstra's algorithm implementation
void dijkstra(GraphList* g, int startVertex) {
    int distances[MAX_VERTICES];
    bool visited[MAX_VERTICES] = {false};
    
    // Initialize distances
    for (int i = 0; i < g->numVertices; i++) {
        distances[i] = INF;
    }
    distances[startVertex] = 0;
    
    printf("Dijkstra's algorithm from vertex %d:\n", startVertex);
    
    for (int count = 0; count < g->numVertices - 1; count++) {
        // Find vertex with minimum distance
        int minDistance = INF;
        int minVertex = -1;
        
        for (int v = 0; v < g->numVertices; v++) {
            if (!visited[v] && distances[v] < minDistance) {
                minDistance = distances[v];
                minVertex = v;
            }
        }
        
        if (minVertex == -1) break;
        
        visited[minVertex] = true;
        
        // Update distances of adjacent vertices
        Node* temp = g->adjLists[minVertex];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            int edgeWeight = 1; // Assuming unweighted for simplicity
            
            if (!visited[adjVertex] && 
                distances[minVertex] + edgeWeight < distances[adjVertex]) {
                distances[adjVertex] = distances[minVertex] + edgeWeight;
            }
            temp = temp->next;
        }
    }
    
    // Print distances
    printf("Vertex\tDistance from Source\n");
    for (int i = 0; i < g->numVertices; i++) {
        printf("%d\t", i);
        if (distances[i] == INF) {
            printf("INF\n");
        } else {
            printf("%d\n", distances[i]);
        }
    }
}

// Kruskal's algorithm (simplified version)
typedef struct {
    int src, dest, weight;
} Edge;

typedef struct {
    int parent;
    int rank;
} Subset;

int find(Subset subsets[], int i) {
    if (subsets[i].parent != i) {
        subsets[i].parent = find(subsets, subsets[i].parent);
    }
    return subsets[i].parent;
}

void unionSets(Subset subsets[], int x, int y) {
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);
    
    if (subsets[xroot].rank < subsets[yroot].rank) {
        subsets[xroot].parent = yroot;
    } else if (subsets[xroot].rank > subsets[yroot].rank) {
        subsets[yroot].parent = xroot;
    } else {
        subsets[yroot].parent = xroot;
        subsets[xroot].rank++;
    }
}

int compareEdges(const void* a, const void* b) {
    Edge* edge1 = (Edge*)a;
    Edge* edge2 = (Edge*)b;
    return edge1->weight - edge2->weight;
}

void kruskalMST(Edge edges[], int V, int E) {
    Edge result[V - 1];
    int e = 0;
    int i = 0;
    
    qsort(edges, E, sizeof(Edge), compareEdges);
    
    Subset* subsets = (Subset*)malloc(V * sizeof(Subset));
    for (int v = 0; v < V; v++) {
        subsets[v].parent = v;
        subsets[v].rank = 0;
    }
    
    printf("Kruskal's MST:\n");
    printf("Edge\tWeight\n");
    
    while (e < V - 1 && i < E) {
        Edge next_edge = edges[i++];
        
        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);
        
        if (x != y) {
            result[e++] = next_edge;
            unionSets(subsets, x, y);
            printf("%d - %d\t%d\n", next_edge.src, next_edge.dest, next_edge.weight);
        }
    }
    
    free(subsets);
}
                    </div>
                </div>
                
                <div class="formula">
                    MST Properties:
                    <br>
                    ‚Ä¢ Number of edges = |V| - 1
                    <br>
                    ‚Ä¢ No cycles
                    <br>
                    ‚Ä¢ Connects all vertices
                    <br>
                    ‚Ä¢ Minimum total weight
                    <br>
                    <br>
                    Shortest Path Properties:
                    <br>
                    ‚Ä¢ Optimal substructure
                    <br>
                    ‚Ä¢ Triangle inequality: d(u,v) ‚â§ d(u,w) + d(w,v)
                    <br>
                    ‚Ä¢ Non-negative weights for Dijkstra
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">5. Topological Sorting</h2>
        
        <div class="concept">
            <div class="simple-explanation">
                <div class="simple-title">üìã For a 5-Year-Old: What is Topological Sorting?</div>
                <p>Imagine you're building with LEGO blocks! Some blocks need to be placed before others - you can't put the roof on before the walls! Topological sorting is like making a list that tells you the right order to do things, making sure you never try to do something before the things it depends on are done!</p>
            </div>
            
            <div class="deep-explanation">
                <div class="deep-title">üîÑ Topological Sort of Directed Acyclic Graphs</div>
                <p><strong>Topological Sort</strong> is a linear ordering of vertices in a directed acyclic graph (DAG) such that for every directed edge (u, v), vertex u comes before vertex v in the ordering.</p>
                
                <div class="svg-container">
                    <svg width="700" height="500" viewBox="0 0 700 500" xmlns="http://www.w3.org/2000/svg">
                        <!-- DAG Example -->
                        <g transform="translate(350, 50)">
                            <text x="0" y="0" text-anchor="middle" font-size="18" font-weight="bold" fill="#2c3e50">Directed Acyclic Graph (DAG)</text>
                            
                            <!-- Vertices -->
                            <circle cx="0" cy="60" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="0" y="65" text-anchor="middle" fill="white" font-weight="bold">A</text>
                            
                            <circle cx="-120" cy="140" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-120" y="145" text-anchor="middle" fill="white" font-weight="bold">B</text>
                            
                            <circle cx="120" cy="140" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="120" y="145" text-anchor="middle" fill="white" font-weight="bold">C</text>
                            
                            <circle cx="-180" cy="240" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-180" y="245" text-anchor="middle" fill="white" font-weight="bold">D</text>
                            
                            <circle cx="-60" cy="240" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="-60" y="245" text-anchor="middle" fill="white" font-weight="bold">E</text>
                            
                            <circle cx="60" cy="240" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="60" y="245" text-anchor="middle" fill="white" font-weight="bold">F</text>
                            
                            <circle cx="180" cy="240" r="20" fill="#3498db" stroke="#2c3e50" stroke-width="2"/>
                            <text x="180" y="245" text-anchor="middle" fill="white" font-weight="bold">G</text>
                            
                            <!-- Directed edges with arrows -->
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#2c3e50"/>
                                </marker>
                            </defs>
                            
                            <line x1="0" y1="80" x2="-120" y2="120" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                            <line x1="0" y1="80" x2="120" y2="120" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                            <line x1="-120" y1="160" x2="-180" y2="220" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                            <line x1="-120" y1="160" x2="-60" y2="220" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                            <line x1="120" y1="160" x2="60" y2="220" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                            <line x1="120" y1="160" x2="180" y2="220" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                            <line x1="-60" y1="240" x2="60" y2="240" stroke="#2c3e50" stroke-width="2" marker-end="url(#arrowhead)"/>
                        </g>
                        
                        <!-- Topological Sort Results -->
                        <g transform="translate(50, 340)">
                            <text x="300" y="0" text-anchor="middle" font-size="16" font-weight="bold" fill="#2c3e50">Topological Sort Results</text>
                            
                            <!-- Possible topological orders -->
                            <rect x="0" y="20" width="600" height="40" fill="#27ae60" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="10" y="35" font-size="12" fill="white" font-weight="bold">Valid Order 1:</text>
                            <text x="10" y="50" font-size="14" fill="white">A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí F ‚Üí G</text>
                            
                            <rect x="0" y="70" width="600" height="40" fill="#3498db" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="10" y="85" font-size="12" fill="white" font-weight="bold">Valid Order 2:</text>
                            <text x="10" y="100" font-size="14" fill="white">A ‚Üí B ‚Üí D ‚Üí E ‚Üí C ‚Üí F ‚Üí G</text>
                            
                            <rect x="0" y="120" width="600" height="40" fill="#e74c3c" stroke="#2c3e50" stroke-width="2" rx="5"/>
                            <text x="10" y="135" font-size="12" fill="white" font-weight="bold">Invalid Order:</text>
                            <text x="10" y="150" font-size="14" fill="white">A ‚Üí C ‚Üí B ‚Üí D ‚Üí E ‚Üí F ‚Üí G (B depends on A, C depends on A, but B before C violates no constraint)</text>
                        </g>
                    </svg>
                    <div class="svg-caption">Figure 5: Topological Sort of a Directed Acyclic Graph</div>
                </div>
                
                <p><strong>Topological Sort Properties:</strong></p>
                <ul>
                    <li><strong>Applicability:</strong> Only for Directed Acyclic Graphs (DAGs)</li>
                    <li><strong>Multiple Solutions:</strong> A graph can have multiple valid topological orders</li>
                    <li><strong>Linear Extension:</strong> Represents a linear ordering that respects all dependencies</li>
                    <li><strong>Uniqueness:</strong> Unique if and only if the graph has a Hamiltonian path</li>
                </ul>
                
                <p><strong>Algorithms for Topological Sort:</strong></p>
                <ul>
                    <li><strong>Kahn's Algorithm (BFS-based):</strong>
                        <ul>
                            <li>Calculate in-degree for all vertices</li>
                            <li>Enqueue vertices with in-degree 0</li>
                            <li>Remove vertex and decrement in-degree of neighbors</li>
                            <li>Time Complexity: O(V + E)</li>
                        </ul>
                    </li>
                    <li><strong>DFS-based Algorithm:</strong>
                        <ul>
                            <li>Perform DFS and mark vertices as visited</li>
                            <li>Add vertex to result after visiting all neighbors</li>
                            <li>Reverse the result at the end</li>
                            <li>Time Complexity: O(V + E)</li>
                        </ul>
                    </li>
                </ul>
                
                <div class="example">
                    <div class="example-title">üíª Topological Sort Implementation</div>
                    <div class="code">
// Kahn's Algorithm (BFS-based)
void topologicalSortKahn(GraphList* g) {
    int inDegree[MAX_VERTICES] = {0};
    Queue q;
    initQueue(&q);
    int result[MAX_VERTICES];
    int resultIndex = 0;
    
    // Calculate in-degree for all vertices
    for (int i = 0; i < g->numVertices; i++) {
        Node* temp = g->adjLists[i];
        while (temp != NULL) {
            inDegree[temp->vertex]++;
            temp = temp->next;
        }
    }
    
    // Enqueue vertices with in-degree 0
    for (int i = 0; i < g->numVertices; i++) {
        if (inDegree[i] == 0) {
            enqueue(&q, i);
        }
    }
    
    printf("Topological Sort (Kahn's Algorithm): ");
    
    while (!isEmpty(&q)) {
        int currentVertex = dequeue(&q);
        result[resultIndex++] = currentVertex;
        printf("%d ", currentVertex);
        
        // Decrement in-degree of adjacent vertices
        Node* temp = g->adjLists[currentVertex];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            inDegree[adjVertex]--;
            
            if (inDegree[adjVertex] == 0) {
                enqueue(&q, adjVertex);
            }
            temp = temp->next;
        }
    }
    
    // Check for cycle
    if (resultIndex != g->numVertices) {
        printf("\nError: Graph contains a cycle!\n");
    } else {
        printf("\n");
    }
}

// DFS-based Topological Sort
void topologicalSortDFSUtil(GraphList* g, int vertex, bool visited[], int* result, int* resultIndex) {
    visited[vertex] = true;
    
    Node* temp = g->adjLists[vertex];
    while (temp != NULL) {
        int adjVertex = temp->vertex;
        if (!visited[adjVertex]) {
            topologicalSortDFSUtil(g, adjVertex, visited, result, resultIndex);
        }
        temp = temp->next;
    }
    
    result[(*resultIndex)++] = vertex;
}

void topologicalSortDFS(GraphList* g) {
    bool visited[MAX_VERTICES] = {false};
    int result[MAX_VERTICES];
    int resultIndex = 0;
    
    for (int i = 0; i < g->numVertices; i++) {
        if (!visited[i]) {
            topologicalSortDFSUtil(g, i, visited, result, &resultIndex);
        }
    }
    
    printf("Topological Sort (DFS-based): ");
    // Print in reverse order
    for (int i = resultIndex - 1; i >= 0; i--) {
        printf("%d ", result[i]);
    }
    printf("\n");
}

// Cycle detection using DFS
bool isCyclicUtil(GraphList* g, int vertex, bool visited[], bool* recursionStack) {
    if (!visited[vertex]) {
        visited[vertex] = true;
        recursionStack[vertex] = true;
        
        Node* temp = g->adjLists[vertex];
        while (temp != NULL) {
            int adjVertex = temp->vertex;
            
            if (!visited[adjVertex] && isCyclicUtil(g, adjVertex, visited, recursionStack)) {
                return true;
            } else if (recursionStack[adjVertex]) {
                return true;
            }
            temp = temp->next;
        }
    }
    
    recursionStack[vertex] = false;
    return false;
}

bool isCyclic(GraphList* g) {
    bool visited[MAX_VERTICES] = {false};
    bool recursionStack[MAX_VERTICES] = {false};
    
    for (int i = 0; i < g->numVertices; i++) {
        if (isCyclicUtil(g, i, visited, recursionStack)) {
            return true;
        }
    }
    
    return false;
}
                    </div>
                </div>
                
                <p><strong>Applications of Topological Sort:</strong></p>
                <ul>
                    <li><strong>Task Scheduling:</strong> Determining order of tasks with dependencies</li>
                    <li><strong>Course Prerequisites:</strong> Planning course sequences</li>
                    <li><strong>Build Systems:</strong> Determining compilation order</li>
                    <li><strong>Deadlock Detection:</strong> In operating systems</li>
                    <li><strong>Data Processing Pipelines:</strong> Order of operations</li>
                </ul>
                
                <div class="formula">
                    Topological Sort Properties:
                    <br>
                    ‚Ä¢ Only possible for DAGs (Directed Acyclic Graphs)
                    <br>
                    ‚Ä¢ Time Complexity: O(V + E) for both algorithms
                    <br>
                    ‚Ä¢ Space Complexity: O(V) for storage
                    <br>
                    ‚Ä¢ Number of possible orders: Can be exponential in worst case
                    <br>
                    ‚Ä¢ Unique if and only if graph has Hamiltonian path
                </div>
            </div>
        </div>
    </div>

    <div class="section">
        <h2 class="section-title">Module Summary & Exam Focus</h2>
        
        <div class="concept">
            <div class="deep-explanation">
                <div class="deep-title">üéØ Key Exam Topics from Module 4</div>
                
                <p><strong>High-Frequency Exam Questions:</strong></p>
                <ol>
                    <li><strong>Graph Representation:</strong>
                        <ul>
                            <li>Convert between adjacency matrix and adjacency list</li>
                            <li>Calculate space complexity for different representations</li>
                            <li>Choose appropriate representation based on graph properties</li>
                        </ul>
                    </li>
                    
                    <li><strong>Graph Traversal Algorithms:</strong>
                        <ul>
                            <li>Implement BFS and DFS for both matrix and list representations</li>
                            <li>Compare BFS and DFS in terms of applications and performance</li>
                            <li>Find connected components using BFS/DFS</li>
                        </ul>
                    </li>
                    
                    <li><strong>Minimum Spanning Trees:</strong>
                        <ul>
                            <li>Implement Kruskal's and Prim's algorithms</li>
                            <li>Compare MST algorithms in terms of time and space complexity</li>
                            <li>Find MST for given weighted graphs</li>
                        </ul>
                    </li>
                    
                    <li><strong>Shortest Path Algorithms:</strong>
                        <ul>
                            <li>Implement Dijkstra's algorithm</li>
                            <li>Find shortest path between two vertices</li>
                            <li>Handle different graph scenarios (weighted/unweighted, positive/negative weights)</li>
                        </ul>
                    </li>
                    
                    <li><strong>Topological Sorting:</strong>
                        <ul>
                            <li>Implement both Kahn's and DFS-based algorithms</li>
                            <li>Detect cycles in directed graphs</li>
                            <li>Apply topological sort to scheduling problems</li>
                        </ul>
                    </li>
                </ol>
                
                <div class="example">
                    <div class="example-title">üìù Sample Exam Question</div>
                    <p><strong>Question:</strong> Given a weighted graph with 6 vertices and 9 edges, apply Kruskal's algorithm to find the Minimum Spanning Tree. Show each step of the algorithm and calculate the total weight of the MST.</p>
                    <p><strong>Solution Approach:</strong>
                    <br>1. List all edges with their weights
                    <br>2. Sort edges in increasing order of weight
                    <br>3. Initialize Union-Find data structure
                    <br>4. Process edges in sorted order:
                    <br>   - Add edge if it doesn't form a cycle
                    <br>   - Skip edge if it forms a cycle
                    <br>5. Continue until |V|-1 edges are selected
                    <br>6. Show the final MST and calculate total weight
                    <br>7. Verify that all vertices are connected</p>
                </div>
                
                <p><strong>Study Strategy:</strong></p>
                <ul>
                    <li>Master graph representation methods and their trade-offs</li>
                    <li>Practice implementing all traversal algorithms</li>
                    <li>Understand MST algorithms and their applications</li>
                    <li>Learn shortest path algorithms for different scenarios</li>
                    <li>Practice topological sort and cycle detection</li>
                    <li>Work through previous year question papers</li>
                </ul>
                
                <div class="formula">
                    Exam Success = Graph Representation + Traversal Algorithms + MST + Shortest Path + Topological Sort
                </div>
            </div>
        </div>
    </div>

    <div class="citation">
        <p><em>Reference: 2024 Exam Scheme & 2025 Handbook for CST201 Data Structures</em></p>
    </div>
</body>
</html>